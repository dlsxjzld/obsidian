```table-of-contents
title: 
style: nestedList # TOC style (nestedList|nestedOrderedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```
---
배운 것을 모두 외울 필요는 없다. 한두 번 훑어본 뒤 바로 실전 라이브러리 분석으로 넘어가라. 분석하면서 배웠던 것이 기억나지 않는다면 다시 돌아와서 복습하면 된다.

학습 → 실전 라이브러리 분석 → 다시 학습 (애자일 학습 방법?!)
## 2.1 변수, 매개변수, 반환값에 타입을 붙이면 된다
---
- 변수
	const str: string = ‘hello’;

- 매개변수, 반환값
	const minus = (x:number, y:number): number ⇒ x-y;
## 2.2 타입 추론을 적극 활용하자
---
- **`타입스크립트가 타입을 제대로 추론하면 그대로 쓰고, 틀리게 추론할 때만 올바른 타입을 표기한다.`**
- 명시적으로 타입을 부여하지 않아도 타입스크립트는 타입을 알고 있는 경우가 있다.
- 반환값을 어떤 변수에 대입했기 때문에 반환값의 타입은 추론 가능하다.
```ts

const plus = (x, y): number => x + y

const result1 = plus(1, 2) // result1 은 number로 타입 추론됨

  

const plus = (x: number, y: number) => x + y

const result1 = plus(1, 2) // result1 은 number로 타입 추론됨

  

// 문제는 매개변수 x,y에 타입을 지정하지 않아서 암묵적으로 any 타입을 갖고 있다고 추론한다.

// 문제를 해결하면

const plus = (x: number, y: number): number => x + y

```
  

- 리터럴 타입, 넓은 타입
```ts

// const: 리터럴 타입 -> 타입 추론이 더 정확함

const str = "hello" // const str: 'hello'

const num = 123 // const num: 123

const n = null // const n: null

const u = undefined // const n: undefined

const sym = Symbol("sym") // const sym: typeof sym // unique symbol

const obj = { hello: "world" } // const obj: {hello: string}

  

// let: 더 넓은 타입

let str = "hello" // let str: string

let num = 123 // let num: number

let n = null // let n: any

let u = undefined // let n: any

let sym = Symbol("sym") // let sym: Symbol

let obj = { hello: "world" } // let obj: {hello: string}

  

// null과 undefined를 let 변수에 대입할 때는 any로 추론한다.

// unique symbol 끼리는 서로 비교할 수 없다.

```
## 2.3 값 자체가 타입인 리터럴 타입이 있다
---
- 타입 스크립트에서는 표기한 타입과 일치하는 값만 대입할 수 있다. (=== 자바스크립트의 자유도를 희생하는 대신 타입 안정성을 챙기는 언어)

	`let: 더 넓은 타입`, 같은 string이면 넣을 수 있다
	`const: 리터럴 타입`, 표기한 타입과 일치하는 값만 넣을 수 있다

- 함수 리터럴 타입에서는 반환값의 표기법이 다르다. (콜론 대신 ⇒를 사용)
```ts

const plus = (x: number, y: number): number => x + y

const plus: (x: number, y: number) => number = (x, y) => x + y

```

## 2.4 배열 말고 튜플도 있다
---
- 배열의 타입은 **`타입[]`** 또는 **`Array<타입>`**
- **튜플: 각 요소 자리에 타입이 고정되어 있는 배열**
- 튜플은 push, pop, unshift, shift를 막지 않는다.
	push를 사용할 수 있지만 tuple[4]처럼 인덱스에 접근할 수가 없으니 딱히 의미가 없다.
	**push를 사용하는 것까지 막으려면 `readonly`수식어를 붙여줘야 한다**.
	그러면 튜플을 수정할 수 없다.
```ts

const array = [1,2,3]

array[3].toFixed();

// -> array[3] 이 undefined인데도 toFixed를 붙일 수 있는 문제가 있음

  

// 튜플을 통해 해결 가능!

const array: [number, number, number] = [1,2,3]

array[3].toFixed() // -> Object is possibly 'undefined'

  

const tuple: [number,boolean,string] = [1,false,'hi']

tuple.push('hi') // 가능

tuple[4] = 'what' // 에러 발생

  

const tuple: readonly [number,boolean, string] = [1,fals,'hi']

tuple.push('hi') // 수정 할 수 없도록 변경!

```

- **튜플은 길이가 고정된 배열 X, 각 요소 자리에 타입이 고정되어 있는 배열 O**
- …타입[] 표기를 통해 특정 타입이 연달아 나올 수 있다.
```ts

const strNumBools: [string, number, ...boolean[]]

= ['hi', 123, false, true, false]

```

- 타입이 아니라 값에 전개 문법을 사용해도 타입스크립트는 타입 추론을 해낸다.
* 구조분해 할당에서는 나머지 속성 문법을 사용할 수 있으며 이 경우에도 타입을 알아서 추론한다.
```ts

// 값에 전개 문법을 사용

const arr1 = ["hi", true]

const arr = [46, ...arr1]

// const arr: (string | number | boolean)[]

  

// 구조분해 할당 나머지 속성 문법

const [a, ...rest1] = ["hi", 1, 2, 3]

// const a:string, const rest1: [number,number,number]

```

- **타입 뒤에 `?`** 가 붙으면 `옵셔널 수식어`로 `해당 자리에 값이 있어도 그만, 없어도 그만`

- [number, boolean?, string?]

- [number]

- [number, boolean]

- [number, boolean, string]

  

## 2.5 타입으로 쓸 수 있는 것을 구분하자
---
- 값은 일반적으로 자바스크립트에서 사용하는 값
- 타입은 타입을 위한 구문에서 사용하는 타입
- **`타입을 값으로 사용할 수 없다.`**
- **타입으로 사용할 수 있는 값과 타입으로 사용할 수 없는 값만 구분하면 된다.**
- 대부분의 **리터럴 값**은 **타입으로 사용 할 수 있음**
- **변수의 이름**은 **타입으로 사용 할 수 없음.**
- **변수에는 typeof를 앞에 붙여 타입으로 사용할 수 있다.**
- 함수는 자바스크립트에서 일급 객체다. 일급 객체는 값이므로 변수에 할당할 수 있다.
- 함수를 담은 변수의 이름 앞에 typeof를 붙여 타입으로 사용할 수 있다.
- 함수의 호출은 타입으로 사용할 수 없다.
- 함수의 반환값을 타입으로 사용하고 싶다면 3.3절의 ReturnType을 참조
- **클래스의 이름은 typeof 없이도 타입으로 사용할 수 있다.**

## 2.6 유니언 타입으로 OR 관계를 표현하자

^be5007

---
유니언 타입 : 하나의 변수가 여러 타입을 가질 수 있다는 가능성을 표시
유니언 타입 표기 연산자 : `|`
```ts
let strOrNum = string | number = 'hello'
strOrNum = 123
```

* 유니언 타입으로부터 정확한 타입을 찾아내는 기법을 타입 좁히기라고 부름
* 운좋게 각 유니언 타입에 모두 공통적인 속성이 들어 있는 경우에는 타입 좁히기를 할 필요가 없음.
```ts
// 타입 좁히기
function returnNumber(value:string | number):number {
  if(typeof value === 'number'){
    return value // number
  }
  // typeof value === string
  return parseInt(value)
}

// 공통적인 속성 === 타입 좁히기 할 필요 X
function returnString(value:string | number | boolean):string {
  return value.toString()
}
returnString(1)
returnString('1')
returnString(true)
```

## 2.7 타입스크립트에만 있는 타입을 배우자
---
### any
**any 타입은 타입 검사를 포기한다는 선언과 같다. 타입스크립트가 any로 추론하는 타입이 있다면 타입을 직접 표기해야 한다.**

대부분의 경우 타입이 any로 추론되면 다음과 같이 implicitAny 에러가 발생한다.

하지만 다음과 같이 any로 추론 되어도 에러가 발생하지 않는 경우들이 있다.
* 빈 배열
명시적으로 any를 반환하는 경우
* JSON.parse
* fetch
이럴 때는 any가 아닌 타입을 표기하면 된다.
* <{data:string}> 은 제네릭이라는 문법으로 2.14절에서 배운다.
* then 메서드에 타이핑한 것이 어떻게 다음 then 메서드에 영향을 미치는지는 3.10절에서 알아보자.
```ts
const arr = [] // const arr: any[]
const arr: string[] = [] // const arr: string[]

fetch('url').then<{data: string}>((respoonse)=>{
  return response.json()
}).then((result)=>{
  // (parameter) result: {data:string}
})
const result: {hello:string} = JSON.parse('{"hello":"json"}'})
```
### unknown
unknown 은 모든 타입을 대입할 수 있지만, 그 후 어떠한 동작도 수행할 수 없게 된다. 
대부분 try catch 문에서 unknown을 보게 된다.
* e가 unknown이므로 그 뒤에 어떠한 동작도 수행할 수 없게 된다. 
* catch문의 e에는 any와 unknown 외의 타입을 직접 표기할 수 없다. 
	* 이럴 때는 `as로 타입을 주장`할 수 있다. 
	* as : 타입 주장
	* !(non-null assertion) : null이 아님을 주장
	* as와 !는 모두 강제로 주장한 것이므로 자신이 책임져야 합니다.
```ts
try{}
catch(e){ // var e: unknown
  const error = e as Error
  // const error = <Error>e
  console.log(error.message)
}
```
### void
 함수의 반환값이 없는 경우 반환값이 void 타입으로 추론된다.
* void는 함수의 반환값을 무시하도록 하는 특수한 타입이다. 
* 반환값을 실제로 받을 수는 있지만 **타입이 void가 되면서 다른 동작을 더 진행할 수 없게** 된다. 
```ts
const func: ()=>void = ()=>3
const value = func()
console.log("value:",value+4) // Operator '+' cannot be applied to types 'void' and 'number'.(2365)

const func2 = ():void=>3 // Type 'number' is not assignable to type 'void'.
const value2 = func2()
console.log("value2:",value2+4);

const func3: ()=>void | undefined = ()=>3 // Type 'number' is not assignable to type 'void'.
```

* void를 활용하여 반환값을 무시하는 특성은 콜백 함수에 주로 사용한다. 
* 사용자가 그때그때 반환값을 다르게 정할 수 있으므로, 어떠한 반환값이든 다 받을 수 있는 void타입이 등장하게 되었다.
```ts
const callbackfn: (v:number)=>void = (v)=>console.log(v);

[1,2,3].forEach(callbackfn)
[1,2,3].forEach((v:number)=>console.log(v))
```

정리하면 void는 2가지 목적을 위해 사용한다.
1. 사용자가 함수의 반환값을 사용하지 못하도록 제한한다.
2. 반환값을 사용하지 않는 콜백 함수를 타이핑할 때 사용한다.
### {},Object
객체의 타입이 아니라 null, undefined를 제외한 모든 타입을 의미.
* {}타입에 null과 undefined를 합치면 unknown과 비슷해진다.
```ts
const unk: unknown = 'hello'
if(unk){
  unk // const unk: {}
}else{
  unk // const unk: unknown
}
```
### never
never 타입에는 어떠한 타입도 대입할 수 없다. 
* 함수 표현식 : never 타입 반환
* 함수 선언문 : void 타입 반환
	* 함수 선언문은 명시적으로 never타입을 직접 표기해야한다. 
never 타입이 나오는 상황
* while(true) 같이 무한 반복되는 경우 
* throw new Error()

### 2.8 타입 별칭으로 타입에 이름을 붙이자
---
특정 타입을 특정 이름에 저장할 수 있다.
```ts
type A = string
const str: A = 'hello'
```
기존 타입에 새로 이름을 붙인 것을 **`타입 별칭`** 이라고 부른다.
* type 키워드를 사용해서 선언할 수 있다.
* 대문자로 시작하는 단어로 만드는 것이 관습이다.
* 주로 복잡하거나 가독성이 낮은 타입에 붙인다.
* 함수 외에는 객체나 배열을 주로 타입 별칭으로 분리한다.
```ts
const func1: (value:number,unit:string)=>string = (value,unit)=>value+unit

type ValueWithUnit = (value:number, unit:string)=>string
const func2: ValueWithUnit = (value,unit)=>value+unit
```

```ts
type Person = {
  name:string,
  age:number,
  married:boolean
}
const person2:Person = {
  name:'zero',
  age:28,
  married:false
}
```

### 2.9 인터페이스로 객체를 타이핑하자
---
`인터페이스 선언`을 사용하면 객체 타입에 이름을 붙일 수 있다. 
* 객체를 타이핑 하는 방법은 type ([[2장#2.8 타입 별칭으로 타입에 이름을 붙이자]]) 도 있다.
* 타입 별칭과 마찬가지로 `대문자로 시작하는 단어`로 만드는 것이 관습이다.
* ` ; ,` 로 구분 가능하지만 하나로 통일해서 쓰자.
* 인터페이스의 속성 키 자리에 [key: number] 라는 문법이 있는데 이는 이 객체의 length를 제외한 속성 키가 전부 number라는 의미이다. 이 문법을 **`인덱스 시그니처`** 라고 부른다. length는 인덱스 시그니처 이전에 표기했으므로 number가 아니어도 된다.
```ts
interface Person {
  name:string;
  age:number,
  married:boolean
}
const person2:Person = {
  name:'zero',
  age:28,
  married:false
}
```

```ts
interface Func {
  (x:number, y:number): number
}
const add:Func = (x,y)=>x+y

interface Arr {
  length:number,
  [key:number]:string
}
const arr:Arr = ['3','5','7']
console.log(arr) //['3','5','7']
console.log(arr[0]) // '3'
console.log(arr[1]) // '5'
console.log(arr[2]) // '7'
console.log(arr[3]) // undefined
console.log(arr.length) // 3
```

### 2.9.1 인터페이스 선언 병합
---
인터페이스와 인터페이스를 합칠 수 있다.
```ts
interface Merge {
  one:string,
}
interface Merge {
  two:number
}
const example: Merge = {
 one:'1',
 two:2
}
```
* 같은 이름으로 여러 인터페이스를 선언할 수 있다. 이러면 모든 Merge 인터페이스가 하나로 합쳐진다. 이를 `선언 병합`이라고 부른다. 이러한 기능을 만들어둔 이유는 나중에 다른 사람이 인터페이스를 확장할 수 있도록 하기 위함이다.
* 다만 인터페이스 간에 속성이 겹치는데 타입이 다를 경우에는 에러가 발생한다. 속성이 같은 경우에는 타입도 같아야 한다.
```ts
interface Merge {
  one: string;
}
interface Merge {
  one: number; // 에러 발생! 타입도 같게 해야함
}
```

### 2.9.2 네임스페이스
--- 
인터페이스 병합에는 큰 단점이 있다. 남이 만든 인터페이스와 의도치 않게 병합될 수 있다는 점이다.
이럴 때를 대비해서 네임스페이스가 있다.
그러나 네임스페이스도 이름이 겹치면 병합될 수 있다. 
이를 방지하기 위해 [[5장 모듈파일]]이 있다.

* `export` 반드시 필요하다.
* namespace 중첩 된다.
* namespace 내부에 실제 값을 선언한 경우, 네임스페이스 자체를 자바스크립트 값으로 사용할 수 있다.
	* 네임스페이스 내부의 값은 []를 사용해서 접근할 수 있지만, 내부의 타입은 []를 사용해서 접근할 수 없다.
* namespace도 이름이 겹치는 경우 병합된다. 내부에 같은 이름의 인터페이스가 있다면 합쳐지고, 내부에 같은 이름의 타입 별칭이 있다면 에러가 발생한다.
```ts
// export 반드시 필요하다.
namespace Example {
  export interface Inner {
  test:string;
  }
  export type test2 = number;
}
const ex1: Example.Inner = {
  test:'hello',
}
const ex2: Example.test2 = 123
```
```ts
// namespace 중첩
namespace Example {
  export namespace Outer{
    export interface Inner {
      test:string;
    }
    export type test2 = number;
  }
}
const ex1: Example.Outer.Inner = {
  test:'hello',
}
const ex2: Example.Outer.test2 = 123
```
```ts
// 네임스페이스 자체를 자바스크립트 값으로 사용
namespace Ex {
  export const a = 'real'
}
const a = Ex; // {a: 'real'}
const b = Ex.a // 'real'
const c = Ex['a'] // 'real' 
```

### 2.10 객체의 속성과 메서드에 적용되는 특징을 알자
---
객체의 속성에도 옵셔널이나 readonly 수식어가 가능하다.
```ts
interface Example {
  hello:string,
  world?:number, // Example.world?: number | undefined
  readonly wow: boolean,
  readonly multiple?: symbol,
}
const example:Example = {
  hello:'hi',
  wow:false
};
example.no; // 에러! property no does not exist on type 'Example'
example.wow = true // cannot assign to 'wow' because it is a read-only property.
```

에러 메시지는 여러 개가 동시에 표시될 수 있다.
* 밑에 있는 메시지가 더 구체적인 메시지다. 위에서 아래로 읽으면서 구체적인 에러의 위치를 찾아내면 된다.

객체의 속성과 관련한 특이한 점이 있다. 
* 기본적으로 객체를 타이핑할 때 선언하지 않은 속성에 대해서는 에러가 발생한다.
* 그러나 **변수에** **객체 리터럴을 대입**했냐, **변수를 대입**했냐에 따라 타입 검사 방식이 달라진다.
```ts
interface Example {
  hello:string
}

const example: Example = {
  hello:'hi',
  why: '나만 에러야' // 에러 발생
}

const obj = {
  hello:'hi',
  why: '나는 에러 아니야'
}

const example2: Example = obj // 에러 발생 X
```

함수도 마찬가지다. 
* 함수의 **매개변수에 객체 리터럴을 대입**했냐, **변수를 대입**했냐에 따라 타입 검사 방식이 달라진다.
```ts
interface Money {
  amount:number;
  unit:string;
}

const money = {amount: 1000, unit:'won',error:'에러 아님'}

function addMoney (money1:Money,money2:Money):Money{
  return {
    amount: money1.amount + money2.amount,
    unit:'won'
  }
}

addMoney(money,{amount:3000,unit:'money',error:'에러'}) 
// 1번째 인수는 에러발생 X, 2번째 인수에서 에러발생 O
```

객체와 함수
1. 변수를 대입하면 에러가 발생하지 않음
2. 객체 리터럴을 대입하면 에러가 발생함

객체 리터럴을 대입하면 잉여 속성 검사가 실행된다.
* 잉여 속성 검사는 타입 선언에서 선언하지 않은 속성을 사용할 때 에러를 표시하는 것을 의미한다.

변수를 대입할 때는 객체 간 대입 가능성을 비교하게 된다. 
* 2.13절에서 변수를 대입할 때의 상황을 자세하게 알아보자. 

### 2.10.1 인덱스 접근 타입
---
인덱스 접근 타입 : **객체 속성의 타입에 접근하는 방식**

**특정 속성의 타입을 별도 타입으로 만들기**
* 특정한 속성에 연동되게 타입을 만들기
```ts
type Animal {
  name:string
}

type N1 = Animal['name']
type N2 = Animal["name"]
type N3 = Animal.name // 에러!
```

**속성의 키와 값의 타입 구하기**
* **`키의 타입: keyof 객체_타입`** 
* **`값의 타입: 객체_타입[키의 타입]`**
``` ts
const obj = {
  hello: 'world',
  name: 'zero',
  age: 28
}

type Keys = keyof typeof obj
type Values = typeof obj[Keys]
```

* **keyof의 특성**
	* keyof 객체_타입 -> 유니언타입으로 만든다.
	* type Keys = keyof any  ------- type Keys = string | number | Symbol
	* keyof any는 string | number | Symbol
	* 배열에 keyof를 적용하면 'number | 배열_속성_이름_유니언 | 배열_인덱스_문자열_유니언'
	* 배열 속성 이름 : length, forEach, lastIndexOf
	* 배열 인덱스 문자열은 [1,2,3]의 인덱스인 '0' | '1' | '2'
	* ArrayKeys에 문자열 '3'은 안되지만 3은 된다. **모든 number는 배열의 키로 허용되기 때문이다.**

**튜플과 배열에도 인덱스 접근 타입을 사용할 수 있다.**
* El 타입처럼 배열 [number] 인덱스 접근 타입으로 배열 요소들의 모든 타입을 가져올 수 있다.
```ts
type Arr = [1,3,5]
type First = Arr[0]
type Length = Arr['length']
type Arr2 = (string | boolean) []
type El = Arr2[number] // number로 모든 타입을 가져올 수 있다.
```

**인덱스 접근 타입을 활용해서 특정 키들의 값 타입만 추릴 수 있다.**
```ts
const obj = {
  hello: 'world',
  name: 'zero',
  age: 28
}

type Values = typeof obj['hello' | 'name'] // string
```

### 2.10.2 매핑된 객체 타입
---
이전 절에서 **`인덱스 시그니처`** 에 대해 배웠다.
* 인덱스 시그니처: 객체의 속성 값을 전부 특정 타입으로 만들 수 있었다.
```ts
type Index = {
  [key:string]: string
}
```


**속성 전부에 타입을 지정하는 대신 일부 속성에만 타입을 부여**할 수도 있다.
* 인덱스 시그니처에서 사용할 수 있는 타입은 string, number, symbol, 템플릿 리터럴 타입과 이들의 유니언뿐이다.
* 매핑된 객체 타입을 써야 한다. 
	* 기존의 다른 타입으로부터 새로운 객체 속성을 만들어내는 타입
	* 인터페이스에서는 쓰지 못하고 타입 별칭에서만 사용할 수 있다.
	* in 연산자 오른쪽에는 유니언 타입이 와야 한다. 
```ts
type HelloAndHi = {
  [key in 'hello' | 'hi']: string
}
```

**튜플과 배열도 객체이므로 매핑된 객체 타입을 적용할 수 있다.**
* CopyTuple과 CopyArr은 객체 타입이지만 배열을 값으로 받을 수 있다.
	* **구조적 타이핑** 때문이다.

**다른 타입으로부터 값을 가져오면서 수식어를 붙일 수 있다.**
* 읽기 전용: readonly
* 옵셔널: ?
* 수식어 제거하기: -
```ts
interface Original {
  name: string;
  age: number;
  married: boolean;
}

type Copy = {
  readonly [key in keyof Original]?: Original[key] 
  // readonly name?: string | unefined
}

type Copy = {
  -readonly [key in keyof Original]-?: Original[key] 
  // name:string
}
```

**속성 이름을 바꿀 수도 있다.**
* Capitalize: 타입스크립트에서 제공, 문자열의 첫 번째 자리를 대문자화
* as 예약어를 통해 속성 이름을 어떻게 바꿀지 정할 수 있다.
* 템플릿 리터럴을 이용해 바꿀 수도 있다.
```ts
interface Original {
  name: string;
  age: number;
  married: boolean;
}
// Capitalize
type Copy = {
 [key in keyof Original as Capitalize<key>]: Original[key]
}

// 템플릿 리터럴
type Copy2 = {
  [key in keyof Original as `${key}Key`]: Original[key]
}
```

## 2.11 타입을 집합으로 생각하자 (유니언, 인터섹션)
---
2.6절에서 유니언 연산자를 배웠다.
유니언 연산자는 합집합 역할을 한다. 
* string | number 타입은 string 과 number의 합집합이라고 생각할 수 있다.

**`유니언 연산자 : | (합집합)`**
**`인터섹션 연산자 : & (교집합)`**

**원소가 존재하지 않는 집합은 공집합**
* never가 담당한다.
* type nev = string & number; ----- type nev = never

타입스크립트의 타입을 집합 관계로 볼 수 있다.
1. 전체집합 : unknown (가장 넓은 타입)
2. 공집합 : never (가장 좁은 타입)
3. &: 교집합
4. |: 합집합
5. 타입스크립트에서는 좁은 타입을 넓은 타입에 대입할 수 있다. 
6. 반대로 넓은 타입은 좁은 타입에 대입할 수 없다.
**`항상 좁은 타입에서 넓은 타입으로 대입해야 한다.`**

null/undefined를 제외한 원시 자료형과 비어 있지 않은 객체를 & 연산할 때는 never가 되지 않는다.
* 예외사항이다. 타입스크립트에서 종종 활용하는 **브랜딩** 기법.
```ts
type H = {a:'b'} & number // type H = {a:'b'}&number
type I = null & {a:'b'} // type I = never
type J = {} & string // {}은 null과 undefined를 제외한 모든 값을 의미하는 타입 
                     // -> type J = string
```

## 2.12 타입도 상속이 가능하다
---
객체 타입 간에 상속하는 방법이 있다.
* 상속받는다는 것은 더 좁은 타입이 된다는 것을 의미한다. 
* 타입 별칭이 인터페이스를 상속할 수도 있고, 인터페이스가 타입 별칭을 상속할 수도 있다.
* 한 번에 여러 타입을 상속할 수도 있다. 
* extends 예약어
	* interface
* & 연산자
	*  type
```ts
type Animal = {
  name:string
}
// 상속받는다는 것은 더 좁은 타입이 된다는 것을 의미한다.
// 타입 별칭이 인터페이스를 상속할 수도 있고, 인터페이스가 타입 별칭을 상속할 수도 있다.
interface Dog extends Animal {
  bark():void
}
type Cat = Animal & {
  meow():void
}
// 한 번에 여러 타입을 상속할 수도 있다. 
interface DogCat extends Dog,Cat {}
type meow = DogCat['meow']
type bark = DogCat['bark']
```

상속할 때 부모 속성의 타입을 변경할 수도 있다. (좀 더 좁은 타입으로)
다만 완전히 다른 타입으로 변경하면 에러가 발생한다.
``` ts
interface Merge {
  one: string;
  two: string;
}
// 좁은 타입으로 변경 가능
interface Merge2 extends Merge {
  one: 'h' | 'w';
  tow: '123'
}
// 완전히 다른 타입으로 변경하면 에러 발생
interface Merge3 extends Merge {
  one: 'h' | 'w';
  tow: 123 // 에러 발생
}
```

## 2.13 객체 간에 대입할 수 있는지 확인하는 법을 배우자
---
2.11 절에서 배운 가장 중요한 점
**`좁은 타입은 넓은 타입에 대입 할 수 있다.`**
**`넓은 타입은 좁은 타입에 대입 할 수 없다.`**\

A 타입이 B 타입보다 넓은 타입(또는 추상적인 타입)이다.
반대로 B타입은 A타입보다 더 좁은 타입, 또는 더 구체적인 타입이다.
* 이유: B가 상세한 속성 및 조건이 많기 때문이다. 
* {name:string} | {age:number} 는 {name:string, age:number} 또는 {name: string} 또는 {age:number}에 대입 가능할까?
	* 불가능하다
	* {name:string} | {age:number} 가 훨씬 넓은 타입이므로, 좁은 타입들에 대입 할 수 없다. 
```ts
interface A {
  name: string
}
interface B {
  name: string,
  age:number
}

const aObj = {
  name:'zero'
}
const bObj = {
  name:'nero',
  age:32
}
// B는 A에 대입 가능
// A는 B에 대입 불가능

const aToA: A = aObj
const bToA: A = bObj
const aToB: B = aObj // 에러 발생, Property 'age' is missing...
const bTob: B = bObj
```

* 튜플은 배열보다 좁은 타입이다. 따라서 튜플은 배열에 대입할 수 있으나, 배열은 튜플에 대입할 수 없다.
```ts
let a: ['hi','readonly'] = ['hi','readonly']
let b:string[] = ['hi','normal']
console.log(b) // ['hi','normal']
b = a
console.log(b) // ['hi','readonly']

a = b // 에러 발생! Type 'string[]' is not assignable to type '["hi", "readonly"]'.
```

* 배열이나 튜플에는 readonly 수식어를 붙일 수 있다. readonly 수식어가 붙은 배열이 더 넓은 타입이다.
	* 수식어가 없는 배열이나 튜플은 writable 하다. 조건이 더 구체적이라는 의미이므로 readonly 보다 더 좁은 타입이다.

* 두 객체가 있고 속성이 동일할 때, 속성이 옵셔널인 객체가 옵셔널이지 않은 객체보다 더 넓은 타입이다.
	* 옵셔널이란 기존 타입에 undefined가 유니언된 것과 같다.

* 배열과 다르게 객체에서는 속성에 readonly가 붙어도 서로 대입할 수 있다. 

### 2.13.1 구조적 타이핑
---
모든 속성이 동일하면 객체 타입의 이름이 달라도 동일한 타입으로 취급한다.
* ***`구조적 타이핑: 객체를 어떻게 만들었든 간에 구조가 같으면 같은 객체로 인식하는 것`**

```ts
interface Money {
  amount: number;
  unit: string;
}

interface Liter {
  amount: number;
  unit: string;
}

const liter:Liter = {amount:1, unit:'liter'}
const circle:Money = liter
```

* B 인터페이스는 A 인터페이스이기 위한 모든 조건이 충족됨
* B 인터페이스는 구조적 타이핑 관점에서 A 인터페이스라고 볼 수 있다.  
* A는 age가 없으므로 B 인터페이스가 아니다.
```ts
interface A {
  name: string
}
interface B {
  name: string,
  age:number
}
```

서로 대입하지 못하게 하려면 구분하기 위해 속성을 추가하면 된다.
* 서로 `__type` 속성이 다르므로 대입되지 않는다. (속성의 이름은 꼭 `__type`일 필요는 없음)
* 이런 속성을 **브랜드 속성**이라고 한다. 
* **`브랜딩`**: 브랜드 속성을 사용하는 것
```ts
interface Money {
  __type:'money';
  amount: number;
  unit: string;
}

interface Liter {
  __type:'liter';
  amount: number;
  unit: string;
}

const liter:Liter = {amount:1, unit:'liter', __type:'liter'}
const circle:Money = liter // 에러 발생
```
