```table-of-contents
title: 
style: nestedList # TOC style (nestedList|nestedOrderedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```
---
배운 것을 모두 외울 필요는 없다. 한두 번 훑어본 뒤 바로 실전 라이브러리 분석으로 넘어가라. 분석하면서 배웠던 것이 기억나지 않는다면 다시 돌아와서 복습하면 된다.

학습 → 실전 라이브러리 분석 → 다시 학습 (애자일 학습 방법?!)
## 2.1 변수, 매개변수, 반환값에 타입을 붙이면 된다
---
- 변수
	const str: string = ‘hello’;

- 매개변수, 반환값
	const minus = (x:number, y:number): number ⇒ x-y;
## 2.2 타입 추론을 적극 활용하자
---
- **`타입스크립트가 타입을 제대로 추론하면 그대로 쓰고, 틀리게 추론할 때만 올바른 타입을 표기한다.`**
- 명시적으로 타입을 부여하지 않아도 타입스크립트는 타입을 알고 있는 경우가 있다.
- 반환값을 어떤 변수에 대입했기 때문에 반환값의 타입은 추론 가능하다.
```ts

const plus = (x, y): number => x + y

const result1 = plus(1, 2) // result1 은 number로 타입 추론됨

  

const plus = (x: number, y: number) => x + y

const result1 = plus(1, 2) // result1 은 number로 타입 추론됨

  

// 문제는 매개변수 x,y에 타입을 지정하지 않아서 암묵적으로 any 타입을 갖고 있다고 추론한다.

// 문제를 해결하면

const plus = (x: number, y: number): number => x + y

```
  

- 리터럴 타입, 넓은 타입
```ts

// const: 리터럴 타입 -> 타입 추론이 더 정확함

const str = "hello" // const str: 'hello'

const num = 123 // const num: 123

const n = null // const n: null

const u = undefined // const n: undefined

const sym = Symbol("sym") // const sym: typeof sym // unique symbol

const obj = { hello: "world" } // const obj: {hello: string}

  

// let: 더 넓은 타입

let str = "hello" // let str: string

let num = 123 // let num: number

let n = null // let n: any

let u = undefined // let n: any

let sym = Symbol("sym") // let sym: Symbol

let obj = { hello: "world" } // let obj: {hello: string}

  

// null과 undefined를 let 변수에 대입할 때는 any로 추론한다.

// unique symbol 끼리는 서로 비교할 수 없다.

```
## 2.3 값 자체가 타입인 리터럴 타입이 있다
---
- 타입 스크립트에서는 표기한 타입과 일치하는 값만 대입할 수 있다. (=== 자바스크립트의 자유도를 희생하는 대신 타입 안정성을 챙기는 언어)

	`let: 더 넓은 타입`, 같은 string이면 넣을 수 있다
	`const: 리터럴 타입`, 표기한 타입과 일치하는 값만 넣을 수 있다

- 함수 리터럴 타입에서는 반환값의 표기법이 다르다. (콜론 대신 ⇒를 사용)
```ts

const plus = (x: number, y: number): number => x + y

const plus: (x: number, y: number) => number = (x, y) => x + y

```

## 2.4 배열 말고 튜플도 있다
---
- 배열의 타입은 **`타입[]`** 또는 **`Array<타입>`**
- **튜플: 각 요소 자리에 타입이 고정되어 있는 배열**
- 튜플은 push, pop, unshift, shift를 막지 않는다.
	push를 사용할 수 있지만 tuple[4]처럼 인덱스에 접근할 수가 없으니 딱히 의미가 없다.
	**push를 사용하는 것까지 막으려면 `readonly`수식어를 붙여줘야 한다**.
	그러면 튜플을 수정할 수 없다.
```ts

const array = [1,2,3]

array[3].toFixed();

// -> array[3] 이 undefined인데도 toFixed를 붙일 수 있는 문제가 있음

  

// 튜플을 통해 해결 가능!

const array: [number, number, number] = [1,2,3]

array[3].toFixed() // -> Object is possibly 'undefined'

  

const tuple: [number,boolean,string] = [1,false,'hi']

tuple.push('hi') // 가능

tuple[4] = 'what' // 에러 발생

  

const tuple: readonly [number,boolean, string] = [1,fals,'hi']

tuple.push('hi') // 수정 할 수 없도록 변경!

```

- **튜플은 길이가 고정된 배열 X, 각 요소 자리에 타입이 고정되어 있는 배열 O**
- …타입[] 표기를 통해 특정 타입이 연달아 나올 수 있다.
```ts

const strNumBools: [string, number, ...boolean[]]

= ['hi', 123, false, true, false]

```

- 타입이 아니라 값에 전개 문법을 사용해도 타입스크립트는 타입 추론을 해낸다.
* 구조분해 할당에서는 나머지 속성 문법을 사용할 수 있으며 이 경우에도 타입을 알아서 추론한다.
```ts

// 값에 전개 문법을 사용

const arr1 = ["hi", true]

const arr = [46, ...arr1]

// const arr: (string | number | boolean)[]

  

// 구조분해 할당 나머지 속성 문법

const [a, ...rest1] = ["hi", 1, 2, 3]

// const a:string, const rest1: [number,number,number]

```

- **타입 뒤에 `?`** 가 붙으면 `옵셔널 수식어`로 `해당 자리에 값이 있어도 그만, 없어도 그만`

- [number, boolean?, string?]

- [number]

- [number, boolean]

- [number, boolean, string]

  

## 2.5 타입으로 쓸 수 있는 것을 구분하자
---
- 값은 일반적으로 자바스크립트에서 사용하는 값
- 타입은 타입을 위한 구문에서 사용하는 타입
- **`타입을 값으로 사용할 수 없다.`**
- **타입으로 사용할 수 있는 값과 타입으로 사용할 수 없는 값만 구분하면 된다.**
- 대부분의 **리터럴 값**은 **타입으로 사용 할 수 있음**
- **변수의 이름**은 **타입으로 사용 할 수 없음.**
- **변수에는 typeof를 앞에 붙여 타입으로 사용할 수 있다.**
- 함수는 자바스크립트에서 일급 객체다. 일급 객체는 값이므로 변수에 할당할 수 있다.
- 함수를 담은 변수의 이름 앞에 typeof를 붙여 타입으로 사용할 수 있다.
- 함수의 호출은 타입으로 사용할 수 없다.
- 함수의 반환값을 타입으로 사용하고 싶다면 3.3절의 ReturnType을 참조
- **클래스의 이름은 typeof 없이도 타입으로 사용할 수 있다.**

## 2.6 유니언 타입으로 OR 관계를 표현하자

^be5007

---
유니언 타입 : 하나의 변수가 여러 타입을 가질 수 있다는 가능성을 표시
유니언 타입 표기 연산자 : `|`
```ts
let strOrNum = string | number = 'hello'
strOrNum = 123
```

* 유니언 타입으로부터 정확한 타입을 찾아내는 기법을 타입 좁히기라고 부름
* 운좋게 각 유니언 타입에 모두 공통적인 속성이 들어 있는 경우에는 타입 좁히기를 할 필요가 없음.
```ts
// 타입 좁히기
function returnNumber(value:string | number):number {
  if(typeof value === 'number'){
    return value // number
  }
  // typeof value === string
  return parseInt(value)
}

// 공통적인 속성 === 타입 좁히기 할 필요 X
function returnString(value:string | number | boolean):string {
  return value.toString()
}
returnString(1)
returnString('1')
returnString(true)
```

## 2.7 타입스크립트에만 있는 타입을 배우자
---
### any
**any 타입은 타입 검사를 포기한다는 선언과 같다. 타입스크립트가 any로 추론하는 타입이 있다면 타입을 직접 표기해야 한다.**

대부분의 경우 타입이 any로 추론되면 다음과 같이 implicitAny 에러가 발생한다.

하지만 다음과 같이 any로 추론 되어도 에러가 발생하지 않는 경우들이 있다.
* 빈 배열
명시적으로 any를 반환하는 경우
* JSON.parse
* fetch
이럴 때는 any가 아닌 타입을 표기하면 된다.
* <{data:string}> 은 제네릭이라는 문법으로 2.14절에서 배운다.
* then 메서드에 타이핑한 것이 어떻게 다음 then 메서드에 영향을 미치는지는 3.10절에서 알아보자.
```ts
const arr = [] // const arr: any[]
const arr: string[] = [] // const arr: string[]

fetch('url').then<{data: string}>((respoonse)=>{
  return response.json()
}).then((result)=>{
  // (parameter) result: {data:string}
})
const result: {hello:string} = JSON.parse('{"hello":"json"}'})
```
### unknown
unknown 은 모든 타입을 대입할 수 있지만, 그 후 어떠한 동작도 수행할 수 없게 된다. 
대부분 try catch 문에서 unknown을 보게 된다.
* e가 unknown이므로 그 뒤에 어떠한 동작도 수행할 수 없게 된다. 
* catch문의 e에는 any와 unknown 외의 타입을 직접 표기할 수 없다. 
	* 이럴 때는 `as로 타입을 주장`할 수 있다. 
	* as : 타입 주장
	* !(non-null assertion) : null이 아님을 주장
	* as와 !는 모두 강제로 주장한 것이므로 자신이 책임져야 합니다.
```ts
try{}
catch(e){ // var e: unknown
  const error = e as Error
  // const error = <Error>e
  console.log(error.message)
}
```
### void
 함수의 반환값이 없는 경우 반환값이 void 타입으로 추론된다.
* void는 함수의 반환값을 무시하도록 하는 특수한 타입이다. 
* 반환값을 실제로 받을 수는 있지만 **타입이 void가 되면서 다른 동작을 더 진행할 수 없게** 된다. 
```ts
const func: ()=>void = ()=>3
const value = func()
console.log("value:",value+4) // Operator '+' cannot be applied to types 'void' and 'number'.(2365)

const func2 = ():void=>3 // Type 'number' is not assignable to type 'void'.
const value2 = func2()
console.log("value2:",value2+4);

const func3: ()=>void | undefined = ()=>3 // Type 'number' is not assignable to type 'void'.
```

* void를 활용하여 반환값을 무시하는 특성은 콜백 함수에 주로 사용한다. 
* 사용자가 그때그때 반환값을 다르게 정할 수 있으므로, 어떠한 반환값이든 다 받을 수 있는 void타입이 등장하게 되었다.
```ts
const callbackfn: (v:number)=>void = (v)=>console.log(v);

[1,2,3].forEach(callbackfn)
[1,2,3].forEach((v:number)=>console.log(v))
```

정리하면 void는 2가지 목적을 위해 사용한다.
1. 사용자가 함수의 반환값을 사용하지 못하도록 제한한다.
2. 반환값을 사용하지 않는 콜백 함수를 타이핑할 때 사용한다.
### {},Object
객체의 타입이 아니라 null, undefined를 제외한 모든 타입을 의미.
* {}타입에 null과 undefined를 합치면 unknown과 비슷해진다.
```ts
const unk: unknown = 'hello'
if(unk){
  unk // const unk: {}
}else{
  unk // const unk: unknown
}
```
### never
never 타입에는 어떠한 타입도 대입할 수 없다. 
* 함수 표현식 : never 타입 반환
* 함수 선언문 : void 타입 반환
	* 함수 선언문은 명시적으로 never타입을 직접 표기해야한다. 
never 타입이 나오는 상황
* while(true) 같이 무한 반복되는 경우 
* throw new Error()

### 2.8 타입 별칭으로 타입에 이름을 붙이자
---
특정 타입을 특정 이름에 저장할 수 있다.
```ts
type A = string
const str: A = 'hello'
```
기존 타입에 새로 이름을 붙인 것을 **`타입 별칭`** 이라고 부른다.
* type 키워드를 사용해서 선언할 수 있다.
* 대문자로 시작하는 단어로 만드는 것이 관습이다.
* 주로 복잡하거나 가독성이 낮은 타입에 붙인다.
* 함수 외에는 객체나 배열을 주로 타입 별칭으로 분리한다.
```ts
const func1: (value:number,unit:string)=>string = (value,unit)=>value+unit

type ValueWithUnit = (value:number, unit:string)=>string
const func2: ValueWithUnit = (value,unit)=>value+unit
```

```ts
type Person = {
  name:string,
  age:number,
  married:boolean
}
const person2:Person = {
  name:'zero',
  age:28,
  married:false
}
```

### 2.9 인터페이스로 객체를 타이핑하자
---
`인터페이스 선언`을 사용하면 객체 타입에 이름을 붙일 수 있다. 
* 객체를 타이핑 하는 방법은 type ([[2장#2.8 타입 별칭으로 타입에 이름을 붙이자]]) 도 있다.
* 타입 별칭과 마찬가지로 `대문자로 시작하는 단어`로 만드는 것이 관습이다.
* ` ; ,` 로 구분 가능하지만 하나로 통일해서 쓰자.
* 인터페이스의 속성 키 자리에 [key: number] 라는 문법이 있는데 이는 이 객체의 length를 제외한 속성 키가 전부 number라는 의미이다. 이 문법을 **`인덱스 시그니처`** 라고 부른다. length는 인덱스 시그니처 이전에 표기했으므로 number가 아니어도 된다.
```ts
interface Person {
  name:string;
  age:number,
  married:boolean
}
const person2:Person = {
  name:'zero',
  age:28,
  married:false
}
```

```ts
interface Func {
  (x:number, y:number): number
}
const add:Func = (x,y)=>x+y

interface Arr {
  length:number,
  [key:number]:string
}
const arr:Arr = ['3','5','7']
console.log(arr) //['3','5','7']
console.log(arr[0]) // '3'
console.log(arr[1]) // '5'
console.log(arr[2]) // '7'
console.log(arr[3]) // undefined
console.log(arr.length) // 3
```

### 2.9.1 인터페이스 선언 병합
---
인터페이스와 인터페이스를 합칠 수 있다.
```ts
interface Merge {
  one:string,
}
interface Merge {
  two:number
}
const example: Merge = {
 one:'1',
 two:2
}
```
* 같은 이름으로 여러 인터페이스를 선언할 수 있다. 이러면 모든 Merge 인터페이스가 하나로 합쳐진다. 이를 `선언 병합`이라고 부른다. 이러한 기능을 만들어둔 이유는 나중에 다른 사람이 인터페이스를 확장할 수 있도록 하기 위함이다.
* 다만 인터페이스 간에 속성이 겹치는데 타입이 다를 경우에는 에러가 발생한다. 속성이 같은 경우에는 타입도 같아야 한다.
```ts
interface Merge {
  one: string;
}
interface Merge {
  one: number; // 에러 발생! 타입도 같게 해야함
}
```

### 2.9.2 네임스페이스
--- 
인터페이스 병합에는 큰 단점이 있다. 남이 만든 인터페이스와 의도치 않게 병합될 수 있다는 점이다.
이럴 때를 대비해서 네임스페이스가 있다.
그러나 네임스페이스도 이름이 겹치면 병합될 수 있다. 
이를 방지하기 위해 [[5장 모듈파일]]이 있다.

* `export` 반드시 필요하다.
* namespace 중첩 된다.
* namespace 내부에 실제 값을 선언한 경우, 네임스페이스 자체를 자바스크립트 값으로 사용할 수 있다.
	* 네임스페이스 내부의 값은 []를 사용해서 접근할 수 있지만, 내부의 타입은 []를 사용해서 접근할 수 없다.
* namespace도 이름이 겹치는 경우 병합된다. 내부에 같은 이름의 인터페이스가 있다면 합쳐지고, 내부에 같은 이름의 타입 별칭이 있다면 에러가 발생한다.
```ts
// export 반드시 필요하다.
namespace Example {
  export interface Inner {
  test:string;
  }
  export type test2 = number;
}
const ex1: Example.Inner = {
  test:'hello',
}
const ex2: Example.test2 = 123
```
```ts
// namespace 중첩
namespace Example {
  export namespace Outer{
    export interface Inner {
      test:string;
    }
    export type test2 = number;
  }
}
const ex1: Example.Outer.Inner = {
  test:'hello',
}
const ex2: Example.Outer.test2 = 123
```
```ts
// 네임스페이스 자체를 자바스크립트 값으로 사용
namespace Ex {
  export const a = 'real'
}
const a = Ex; // {a: 'real'}
const b = Ex.a // 'real'
const c = Ex['a'] // 'real' 
```

### 2.10 객체의 속성과 메서드에 적용되는 특징을 알자
---
객체의 속성에도 옵셔널이나 readonly 수식어가 가능하다.
```ts
interface Example {
  hello:string,
  world?:number, // Example.world?: number | undefined
  readonly wow: boolean,
  readonly multiple?: symbol,
}
const example:Example = {
  hello:'hi',
  wow:false
};
example.no; // 에러! property no does not exist on type 'Example'
example.wow = true // cannot assign to 'wow' because it is a read-only property.
```

에러 메시지는 여러 개가 동시에 표시될 수 있다.
* 밑에 있는 메시지가 더 구체적인 메시지다. 위에서 아래로 읽으면서 구체적인 에러의 위치를 찾아내면 된다.

객체의 속성과 관련한 특이한 점이 있다. 
* 기본적으로 객체를 타이핑할 때 선언하지 않은 속성에 대해서는 에러가 발생한다.
* 그러나 **변수에** **객체 리터럴을 대입**했냐, **변수를 대입**했냐에 따라 타입 검사 방식이 달라진다.
```ts
interface Example {
  hello:string
}

const example: Example = {
  hello:'hi',
  why: '나만 에러야' // 에러 발생
}

const obj = {
  hello:'hi',
  why: '나는 에러 아니야'
}

const example2: Example = obj // 에러 발생 X
```

함수도 마찬가지다. 
* 함수의 **매개변수에 객체 리터럴을 대입**했냐, **변수를 대입**했냐에 따라 타입 검사 방식이 달라진다.
```ts
interface Money {
  amount:number;
  unit:string;
}

const money = {amount: 1000, unit:'won',error:'에러 아님'}

function addMoney (money1:Money,money2:Money):Money{
  return {
    amount: money1.amount + money2.amount,
    unit:'won'
  }
}

addMoney(money,{amount:3000,unit:'money',error:'에러'}) 
// 1번째 인수는 에러발생 X, 2번째 인수에서 에러발생 O
```

객체와 함수
1. 변수를 대입하면 에러가 발생하지 않음
2. 객체 리터럴을 대입하면 에러가 발생함

객체 리터럴을 대입하면 잉여 속성 검사가 실행된다.
* 잉여 속성 검사는 타입 선언에서 선언하지 않은 속성을 사용할 때 에러를 표시하는 것을 의미한다.

변수를 대입할 때는 객체 간 대입 가능성을 비교하게 된다. 
* 2.13절에서 변수를 대입할 때의 상황을 자세하게 알아보자. 

### 2.10.1 인덱스 접근 타입
---
인덱스 접근 타입 : **객체 속성의 타입에 접근하는 방식**

**특정 속성의 타입을 별도 타입으로 만들기**
* 특정한 속성에 연동되게 타입을 만들기
```ts
type Animal {
  name:string
}

type N1 = Animal['name']
type N2 = Animal["name"]
type N3 = Animal.name // 에러!
```

**속성의 키와 값의 타입 구하기**
* **`키의 타입: keyof 객체_타입`** 
* **`값의 타입: 객체_타입[키의 타입]`**
``` ts
const obj = {
  hello: 'world',
  name: 'zero',
  age: 28
}

type Keys = keyof typeof obj // 'hello' | 'name' | 'age'
type Values = typeof obj[Keys] // 
```

* typeof: 객체에 쓰면 객체를 타입으로 만든다. 
* keyof: 객체의 키들을 꺼내서 유니언타입으로 만든다.
	* [typeof keyof](https://inpa.tistory.com/entry/TS-%F0%9F%93%98-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-keyof-typeof-%EC%82%AC%EC%9A%A9%EB%B2%95)
* **keyof의 특성**
	* keyof 객체_타입 -> 유니언타입으로 만든다.
	* type Keys = keyof any  ------- type Keys = string | number | Symbol
	* keyof any는 string | number | Symbol
	* 배열에 keyof를 적용하면 'number | 배열_속성_이름_유니언 | 배열_인덱스_문자열_유니언'
	* 배열 속성 이름 : length, forEach, lastIndexOf
	* 배열 인덱스 문자열은 [1,2,3]의 인덱스인 '0' | '1' | '2'
	* ArrayKeys에 문자열 '3'은 안되지만 3은 된다. **모든 number는 배열의 키로 허용되기 때문이다.**

**튜플과 배열에도 인덱스 접근 타입을 사용할 수 있다.**
* El 타입처럼 배열 [number] 인덱스 접근 타입으로 배열 요소들의 모든 타입을 가져올 수 있다.
```ts
type Arr = [1,3,5]
type First = Arr[0]
type Length = Arr['length']
type Arr2 = (string | boolean) []
type El = Arr2[number] // number로 모든 타입을 가져올 수 있다.
```

**인덱스 접근 타입을 활용해서 특정 키들의 값 타입만 추릴 수 있다.**
```ts
const obj = {
  hello: 'world',
  name: 'zero',
  age: 28
}

type Values = typeof obj['hello' | 'name'] // string
```

### 2.10.2 매핑된 객체 타입
---
이전 절에서 **`인덱스 시그니처`** 에 대해 배웠다.
* 인덱스 시그니처: 객체의 속성 값을 전부 특정 타입으로 만들 수 있었다.
```ts
type Index = {
  [key:string]: string
}
```


**속성 전부에 타입을 지정하는 대신 일부 속성에만 타입을 부여**할 수도 있다.
* 인덱스 시그니처에서 사용할 수 있는 타입은 string, number, symbol, 템플릿 리터럴 타입과 이들의 유니언뿐이다.
* 매핑된 객체 타입을 써야 한다. 
	* 기존의 다른 타입으로부터 새로운 객체 속성을 만들어내는 타입
	* 인터페이스에서는 쓰지 못하고 타입 별칭에서만 사용할 수 있다.
	* in 연산자 오른쪽에는 유니언 타입이 와야 한다. 
```ts
type HelloAndHi = {
  [key in 'hello' | 'hi']: string
}
```

**튜플과 배열도 객체이므로 매핑된 객체 타입을 적용할 수 있다.**
* CopyTuple과 CopyArr은 객체 타입이지만 배열을 값으로 받을 수 있다.
	* **[구조적 타이핑](https://www.yongdam.sh/blog/effective-typescript-structural-typing)** 때문이다.

**다른 타입으로부터 값을 가져오면서 수식어를 붙일 수 있다.**
* 읽기 전용: readonly
* 옵셔널: ?
* 수식어 제거하기: -
```ts
interface Original {
  name: string;
  age: number;
  married: boolean;
}

type Copy = {
  readonly [key in keyof Original]?: Original[key] 
  // readonly name?: string | unefined
}

type Copy = {
  -readonly [key in keyof Original]-?: Original[key] 
  // name:string
}
```

**속성 이름을 바꿀 수도 있다.**
* Capitalize: 타입스크립트에서 제공, 문자열의 첫 번째 자리를 대문자화
* as 예약어를 통해 속성 이름을 어떻게 바꿀지 정할 수 있다.
* 템플릿 리터럴을 이용해 바꿀 수도 있다.
```ts
interface Original {
  name: string;
  age: number;
  married: boolean;
}
// Capitalize
type Copy = {
 [key in keyof Original as Capitalize<key>]: Original[key]
}

// 템플릿 리터럴
type Copy2 = {
  [key in keyof Original as `${key}Key`]: Original[key]
}
```

## 2.11 타입을 집합으로 생각하자 (유니언, 인터섹션)
---
2.6절에서 유니언 연산자를 배웠다.
유니언 연산자는 합집합 역할을 한다. 
* string | number 타입은 string 과 number의 합집합이라고 생각할 수 있다.

타입을 값의 집합이라고 생각하고 이해하자. (참고자료: 구조적 타이핑 보기)

**`유니언 연산자 : | (합집합)`**
**`인터섹션 연산자 : & (교집합)`**

**원소가 존재하지 않는 집합은 공집합**
* never가 담당한다.
* type nev = string & number; ----- type nev = never

타입스크립트의 타입을 집합 관계로 볼 수 있다.
1. 전체집합 : unknown (가장 넓은 타입)
2. 공집합 : never (가장 좁은 타입)
3. &: 교집합
4. |: 합집합
5. 타입스크립트에서는 좁은 타입을 넓은 타입에 대입할 수 있다. 
6. 반대로 넓은 타입은 좁은 타입에 대입할 수 없다.
**`항상 좁은 타입에서 넓은 타입으로 대입해야 한다.`**

null/undefined를 제외한 원시 자료형과 비어 있지 않은 객체를 & 연산할 때는 never가 되지 않는다.
* 예외사항이다. 타입스크립트에서 종종 활용하는 **브랜딩** 기법.
```ts
type H = {a:'b'} & number // type H = {a:'b'}&number
type I = null & {a:'b'} // type I = never
type J = {} & string // {}은 null과 undefined를 제외한 모든 값을 의미하는 타입 
                     // -> type J = string
```

## 2.12 타입도 상속이 가능하다
---
객체 타입 간에 상속하는 방법이 있다.
* 상속받는다는 것은 더 좁은 타입이 된다는 것을 의미한다. 
* 타입 별칭이 인터페이스를 상속할 수도 있고, 인터페이스가 타입 별칭을 상속할 수도 있다.
* 한 번에 여러 타입을 상속할 수도 있다. 
* extends 예약어
	* interface
	* a extends b : a는 b의 부분집합이다.
* & 연산자
	*  type
```ts
type Animal = {
  name:string
}
// 상속받는다는 것은 더 좁은 타입이 된다는 것을 의미한다.
// 타입 별칭이 인터페이스를 상속할 수도 있고, 인터페이스가 타입 별칭을 상속할 수도 있다.
interface Dog extends Animal {
  bark():void
}
type Cat = Animal & {
  meow():void
}
// 한 번에 여러 타입을 상속할 수도 있다. 
interface DogCat extends Dog,Cat {}
type meow = DogCat['meow']
type bark = DogCat['bark']
```

상속할 때 부모 속성의 타입을 변경할 수도 있다. (좀 더 좁은 타입으로)
다만 완전히 다른 타입으로 변경하면 에러가 발생한다.
``` ts
interface Merge {
  one: string;
  two: string;
}
// 좁은 타입으로 변경 가능
interface Merge2 extends Merge {
  one: 'h' | 'w';
  tow: '123'
}
// 완전히 다른 타입으로 변경하면 에러 발생
interface Merge3 extends Merge {
  one: 'h' | 'w';
  tow: 123 // 에러 발생
}
```

## 2.13 객체 간에 대입할 수 있는지 확인하는 법을 배우자
---
2.11 절에서 배운 가장 중요한 점
**`좁은 타입은 넓은 타입에 대입 할 수 있다.`**
**`넓은 타입은 좁은 타입에 대입 할 수 없다.`**\

A 타입이 B 타입보다 넓은 타입(또는 추상적인 타입)이다.
반대로 B타입은 A타입보다 더 좁은 타입, 또는 더 구체적인 타입이다.
* 이유: B가 상세한 속성 및 조건이 많기 때문이다. 
* {name:string} | {age:number} 는 {name:string, age:number} 또는 {name: string} 또는 {age:number}에 대입 가능할까?
	* 불가능하다
	* {name:string} | {age:number} 가 훨씬 넓은 타입이므로, 좁은 타입들에 대입 할 수 없다. 
```ts
interface A {
  name: string
}
interface B {
  name: string,
  age:number
}

const aObj = {
  name:'zero'
}
const bObj = {
  name:'nero',
  age:32
}
// B는 A에 대입 가능
// A는 B에 대입 불가능

const aToA: A = aObj
const bToA: A = bObj
const aToB: B = aObj // 에러 발생, Property 'age' is missing...
const bTob: B = bObj
```

* 튜플은 배열보다 좁은 타입이다. 따라서 튜플은 배열에 대입할 수 있으나, 배열은 튜플에 대입할 수 없다.
```ts
let a: ['hi','readonly'] = ['hi','readonly']
let b:string[] = ['hi','normal']
console.log(b) // ['hi','normal']
b = a
console.log(b) // ['hi','readonly']

a = b // 에러 발생! Type 'string[]' is not assignable to type '["hi", "readonly"]'.
```

* 배열이나 튜플에는 readonly 수식어를 붙일 수 있다. readonly 수식어가 붙은 배열이 더 넓은 타입이다.
	* 수식어가 없는 배열이나 튜플은 writable 하다. 조건이 더 구체적이라는 의미이므로 readonly 보다 더 좁은 타입이다.

* 두 객체가 있고 속성이 동일할 때, 속성이 옵셔널인 객체가 옵셔널이지 않은 객체보다 더 넓은 타입이다.
	* 옵셔널이란 기존 타입에 undefined가 유니언된 것과 같다.

* 배열과 다르게 객체에서는 속성에 readonly가 붙어도 서로 대입할 수 있다. 

### 2.13.1 구조적 타이핑
---
모든 속성이 동일하면 객체 타입의 이름이 달라도 동일한 타입으로 취급한다.
* **[구조적 타이핑](https://www.yongdam.sh/blog/effective-typescript-structural-typing): 객체를 어떻게 만들었든 간에 구조가 같으면 같은 객체로 인식하는 것**

```ts
interface Money {
  amount: number;
  unit: string;
}

interface Liter {
  amount: number;
  unit: string;
}

const liter:Liter = {amount:1, unit:'liter'}
const circle:Money = liter
```

* B 인터페이스는 A 인터페이스이기 위한 모든 조건이 충족됨
* B 인터페이스는 구조적 타이핑 관점에서 A 인터페이스라고 볼 수 있다.  
* A는 age가 없으므로 B 인터페이스가 아니다.
```ts
interface A {
  name: string
}
interface B {
  name: string,
  age:number
}
```

서로 대입하지 못하게 하려면 구분하기 위해 속성을 추가하면 된다.
* 서로 `__type` 속성이 다르므로 대입되지 않는다. (속성의 이름은 꼭 `__type`일 필요는 없음)
* 이런 속성을 **브랜드 속성**이라고 한다. 
* **`브랜딩`**: 브랜드 속성을 사용하는 것
```ts
interface Money {
  __type:'money';
  amount: number;
  unit: string;
}

interface Liter {
  __type:'liter';
  amount: number;
  unit: string;
}

const liter:Liter = {amount:1, unit:'liter', __type:'liter'}
const circle:Money = liter // 에러 발생
```


## 2.14 제네릭으로 타입을 함수처럼 사용하자
### 제네릭을 사용하는 이유
* 타입 간에 중복되는 부분을 없애고 하나의 타입을 여러 방법으로 재사용할 수 있다.
### 제네릭 사용 방법
* 제네릭 표기는 <>로 하며, 인터페이스 이름 바로 뒤에 위치한다.
	* 타입 매개변수의 개수와 타입 인수의 개수를 일치시킨다.
	* 배열의 타입을 표기할 때 사용했던 Array도 제네릭 타입이다. Array<>
* 인터페이스뿐만 아니라 클래스와 타입 별칭, 함수도 제네릭을 가질 수 있다.
	* 함수는 함수 선언문이냐 표현식이냐에 따라 제네릭 표기 위치가 달라진다.
		* 함수 선언문: 함수 이름 뒤 `ex) function x<N,A>(name:N,age:A){...}`
		* 함수 표현식: 함수 이름과 매개변수 사이 `ex) const x = <N,A>(name:N,age:A)=>...`
	* interface와 type 간에 교차 사용도 가능
	* 객체나 클래스의 메서드에 따로 제네릭을 표기할 수 있다.
* 타입 매개변수에는 기본값을 사용할 수 있다.
* 타입스크립트는 제네릭에 직접 타입을 넣지 않아도 추론을 통해 타입을 알아낼 수 있다.
	* **추론한 타입이 잘못된 타입일 경우 직접 타입을 넣자!**
* 상수 타입 매개변수 (5.0 버전부터 추가)

#### 정리
* interface 이름<타입 매개변수들>{...}
* type 이름<타입 매개변수들>{...}
* class 이름<타입 매개변수들>{...}
* function 이름<타입 매개변수들>(...) {...}
* const 함수이름 = <타입 매개변수들>(...) => {...}

#### 제네릭 표기는 <>로 하며, 인터페이스 이름 바로 뒤에 위치한다.
```ts
interface Person <N,A>{
  type:'human',
  race:'yellow',
  name:N,
  age:A
}

interface Zero extends Person <'zero',28>{}
```

#### 배열의 타입을 표기할 때 사용했던 Array도 제네릭 타입이기 때문에 <> 부분이 있는 것이다.
```ts
// 제네릭
interface Array<T>{
  [key:number]:T,
  length:number,
  // 기타 속성들
}

// 제네릭이 없었다면 이렇게 하나씩 설정해야함
interface StringArray {
  [key:number]:String,
  length:number
}
interface BooleanArray {
  [key:number]:BooleanArray,
  length:number
}

// 제네릭 적용시
interface StringArray extends Array<String>{}
interface BooleanArray extends Array<BooleanArray>{}
```

#### 클래스, 타입 별칭도 제네릭을 가질 수 있다.
* 객체나 클래스의 메서드에 따로 제네릭을 표기할 수 있다.
```ts
type Person <N,A> = {
  type:'human',
  race:'yellow',
  name:N,
  age:A
}
type Zero = Person <'zero',28>
type Nero = Person <'nero',32>

class Person<N,A>{
  name:N;
  age:A;
  constructor(name:N,age:A){
    this.name = name;
    this.age = age;
  }
  method<B>(param:B){}
}
```

#### 함수도 제네릭을 가질 수 있다. 주의할 점은, 함수 선언문과 표현식의 제네릭 표기 위치가 다르다.
```ts
// 표현식
const personFactoryE = <N,A>(name:N,age:A)=>({
  type:'human',
  race:'yellow',
  name:N,
  age:A
})

// 선언문
function personFactoryD<N,A>(name:N,age:A){
  return ({
    type:'human',
    race:'yellow',
    name:N,
    age:A
  })
}
```

#### interface와 type 간에 교차 사용도 가능
```ts
interface IPerson <N,A>{
  type:'human',
  race:'yellow',
  name:N,
  age:A
}
type TPerson <N,A> = {
  type:'human',
  race:'yellow',
  name:N,
  age:A
}
type Zero = IPerson<'zero',28>
interface Nero extends TPerson<'nero',32>{}
```

#### 타입스크립트는 제네릭에 직접 타입을 넣지 않아도 추론을 통해 타입을 알아낼 수 있다.
```ts
interface Person <N,A>{
  type:'human',
  race:'yellow',
  name:N,
  age:A
}

const personFactoryE = <N,A = unknown>(name:N,age:A):Person<N,A> => ({
  type:'human',
  race:'yellow',
  name,
  age,
})

const zero = personFactoryE('zero',28) // const zero: Person<string, number>
```

#### 상수 타입 매개변수
* T를 string 대신 'a' | 'b' | 'c' 같은 요소의 유니언으로 추론되게 하려면 어떻게 하면 될까?
```ts
// 기존 코드 (넓은 타입)
// 타입 매개변수 T는 ['a','b','c']이 string[]으로 추론되므로 string이 됨
function values <T>(initial: T[]){
  return{
    hasValue(value:T){return initial.includes(value)}
  }
}
const savedValues = values(['a','b','c'])
console.log(savedValues.hasValue('x'))

// 4.9버전 readonly, as const
function values <T>(initial: readonly T[]){
  return{
    hasValue(value:T){return initial.includes(value)}
  }
}
const savedValues = values(['a','b','c'] as const)
console.log(savedValues.hasValue('x'))

// 5.0버전 <const T>
function values <const T>(initial: T[]){
  return{
    hasValue(value:T){return initial.includes(value)}
  }
}
const savedValues = values(['a','b','c'])
console.log(savedValues.hasValue('x'))
```

### 2.14.1 제네릭에 제약 걸기
#### 타입 매개변수에는 제약을 사용할 수 있다.
* 매개변수에 extends 문법
	* 타입의 상속을 의미하던 extends와는 사용법이 다르다.
* 기본값으로 지정한 타입과 완전히 다른 타입을 제공할 수 있지만, 제약에 어긋나는 타입은 제공할 수 없다.
* 하나의 타입 매개변수가 다른 타입 매개변수의 제약이 될 수도 있다.
* 자주 쓰는 제약들
	* 각각 타입 매개변수가 객체, 배열, 함수, 생성자, 속성의 키여야 한다는 제약을 나타낸다.
* **타입 매개변수와 제약을 동일하게 생각하면 안된다.**

기본값으로 지정한 타입과 완전히 다른 타입을 제공할 수 있지만, 제약에 어긋나는 타입은 제공할 수 없다.
```ts
interface Example <A extends number, B=string>{
  a:A,
  b:B
}
type Usecase1 = Example<string,boolean> // Type 'string' does not satisfy the constraint 'number'
type Usecase2 = Example<1,boolean>
type Usecase3 = Example<number>
```

하나의 타입 매개변수가 다른 타입 매개변수의 제약이 될 수 있다
```ts
interface Example <A, B extends A>{
  a:A,
  b:B
}
type Usecase1 = Example<string,number> // Type 'number' does not satisfy the constraint 'string'
type Usecase2 = Example<string,'hello'>
type Usecase3 = Example<number,123>
```

자주 쓰는 제약들
```ts
<T extends object> // 모든 객체
<T extends any[]> // 모든 배열
<T extends (...args:any)=>any> // 모든 함수
<T extends abstract new (...args: any)=>any> // 생성자 타입
<T extends keyof any> // string | number | symbol
```

**타입 매개변수와 제약을 동일하게 생각하면 안된다.**
* **좁은 타입은 넓은 타입에 대입할 수 있다**. 
* 타입 매개변수가 제약에 대입할 수 있는 타입인지를 따져보아야 한다.
* 해결 방안
	* 제네릭을 쓰지 않으면 된다.
	* 원시값 타입만 사용한다면 대부분 제약을 걸지 않아도 되는 경우가 많다.

에러 발생 코드
```ts
// 에러 발생 코드
interface VO {
  value:any
}

const returnVO = <T extends VO>():T =>{
  return {value:'test'} // 에러 발생 
}
/*
Type '{ value: string; }' is not assignable to type 'T'.  
'{ value: string; }' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'VO'.
*/

// T는 정확히 VO가 아니라 VO에 대입할 수 있는 모든 타입을 의미한다.
// T는 VO보다 좁거나 같은 타입. {value:string, another:string}도 T가 될 수 있다.
// 이러면 {value:string}은 T가 아니다. 

function onlyBoolean <T extends boolean>(arg:T=false):T { // T=false 에서 에러 발생
  return arg 
}
/*
Type 'boolean' is not assignable to type 'T'.  
'boolean' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'boolean'.
*/

// T는 boolean이니까 true 아니면 false일 텐데 왜 에러가 발생할까?
// never 때문에 그렇다. never는 모든 타입에 대입할 수 있으므로, 
// T가 never일 수도 있으므로 false를 기본값으로 넣는 것이 불가능하다.
```

해결코드
```ts
// 에러 해결 코드
function onlyBoolean (arg:true | false = true):true | false {
  return arg
}

interface VO {
  value:any
}
const returnVO = ():VO =>{
  return {value:'test'}
}
```

## 2.15 조건문과 비슷한 컨디셔널 타입이 있다
---
### 조건에 따라 다른 타입이 되는 컨디셔널 타입이 있다.
* extends 예약어 사용
* 삼항연산자와 같이 사용된다.
* **`특정 타입 extends 다른 타입 ? 참일 때 타입 : 거짓일 때 타입`**
* **명시적으로 extends 해야만 참이 되는 것이 아니다. (구조적 타이핑)**
* **타입 검사를 위해서도 많이 사용한다.**
* never와 함께 사용할 때도 많다.
	* 제네릭과 더불어 쓸 때만 never가 의미가 있다.
	* 매핑된 객체 타입에서 키가 never이면 해당 속성은 제거된다. 

#### 특정 타입 extends 다른 타입 ? 참일 때 타입 : 거짓일 때 타입
```ts
type A1 = string
type B1 = A1 extends string ? number : boolean // type B1 = number

type A2 = number
type B2 = A2 extends string ? number : boolean // type B2 = boolean
```

#### 명시적으로 extends 해야만 참이 되는 것이 아니다. (구조적 타이핑)
* XY는 X를 명시적으로 extends하지 않음에도, A는 마찬가지로 string이다. XY 타입이 X타입에 대입 가능하므로 extends 하는 것과 다름 없기 때문이다. 
```ts
interface X {
  x:number
}
interface XY {
  x:number;
  y:number;
}
interface YX extends X {
  y:number
}

type A = XY extends X ? string : number // type A = string
type B = YX extends X ? string : number // type B = string
```
#### 타입 검사를 위해서도 많이 사용한다.
```ts
type Result = 'hi' extends string ? true : false // true
type Result2 = [1] extends [string] ? true : false // false
```
#### never와 함께 사용할 때도 많다.
```ts
type Start = string | number
type New = Start extends string | number ? Start[] : never
let n: New = ['hi']
n = [123];
// type New = Start[] 로 하는 게 낫다.
```

제네릭과 더불어 쓰기
```ts
type ChooseArray<A> = A extends string ? string[] : never
type StringArray = ChooseArray<string> // type StringArray = string[]
type Never = ChooseArray<number> // type Never = never
```

매핑된 객체 타입에서 키가 never이면 해당 속성은 제거된다. 
```ts
type OmitByType <O,T> = {
  [k in keyof O as O[k] extends T ? never : k] : O[k]
}

type Result = OmitByType<{
  name:string;
  age:number;
  married:boolean;
  rich:boolean;
},boolean>

/* 
type Result = {
  name: string;
  age: number;
}
*/
```

### 2.15.1 컨디셔널 타입 분배법칙
---
컨디셔널 타입, 제네릭과 never의 조합은 더 복잡한 상황에서 진가를 발휘한다. 
* **검사하려는 타입이 제네릭이면서 유니언이면 분배법칙이 실행됨**
	* `Result<string | number>` 는 `Result<string> | Result<number>`가 된다.
	* 따라서 `Key extends string | boolean ? Key[] : never`를 거치면` string[] : never`가 되고, never는 사라져서 최종적으로 string[] 타입이 된다.
* boolean에 분배법칙이 적용될 때는 조심해야 한다.
	* boolean을 `true | false`로 인식하기 때문이다.
* 분배법칙 막기
	* **배열로 제네릭을 감싸면 분배법칙이 일어나지 않는다.** 
	* `type 타입명<매개변수> = [매개변수] extends [검사하려는 타입] ? true : false`
* never도 분배법칙의 대상이 된다. 
	* never가 유니언으로 보이지는 않지만 유니언이라고 생각하는 것이 좋다.
	* 컨디셔널 타입에서 제네릭과 never가 만나면 never가 된다고 생각하자. never를 타입인수로 사용하려면 분배법칙을 막자. 
* 타입스크립트는 **제네릭이 들어 있는 컨디셔널 타입을 판단할 때 값의 판단을 뒤로 미룬다**.
	* 뒤로 미루지 못하게 배열로 제네릭을 감싸자.
	* 타입 매개변수를 선언할 때 바로 `<[T] extends [string]>`하는 것이 불가능하므로 한 번 더 컨디셔널 타입으로 묶어 선언함 `ex) <T extends ([T] extends [string] ? string : never)>`

#### string | number 타입에서 string[] 타입을 얻고 싶은 상황
```ts
type Start = string | number
type Result<Key> = Key extends string ? Key[]: never
let n: Result<Start> = ['hi'] // let n: string[]
```

#### boolean에 분배법칙이 적용될 때는 조심해야 한다.
* boolean을 `true | false`로 인식하기 때문이다.
```ts
type Start = string | number | boolean
type Result<Key> = Key extends string | boolean ? Key[] : never
let n: Result<Start> = ['hi'] // let n: string[] | false[] | true[]
```

#### 분배법칙 막기
* 'hi' | 3이 string인지 검사하는 타입을 만들어보자. 3은 string이 아니므로 false가 나와야한다.
```ts
// 잘못된 코드
type IsString<T> = T extends string ? true : false
type Result = IsString<'hi'|3>  // type Result = boolean

// 올바른 코드
type IsString<T> = [T] extends [string] ? true : false
type Result = IsString<'hi'|3> // type Result = false
```

#### never도 분배법칙의 대상이 된다. 
```ts
type R<T> = T extends string ? true : false
type RR = R<never> // type RR = never
/*
RR 타입은 true가 아니라 never. T가 never가 되면서 분배법칙이 일어났기 때문이다.
댠, never는 공집합과 같으므로 공집합에서 분배법칙을 실행하는 것은 아무것도 실행하지 않는 것과 같다.
따라서 결과는 never이다.
*/

type IsNever<T> = [T] extends [never] ? true : false
type T = IsNever<never> // type T = true
type F = IsNever<'never'> // type F = false
```
#### 타입스크립트는 제네릭이 들어 있는 컨디셔널 타입을 판단할 때 값의 판단을 뒤로 미룬다.
* 뒤로 미루기 때문에 변수 b에 매개변수 a를 대입할 때까지도 타입스크립트는 `R<T>가 T`라는 것을 알지 못한다. 
* 뒤로 미루지 못하게 배열로 제네릭을 감싸자.
	* 제네릭에 제약을 거는 부분 복잡해짐
	* 타입 매개변수를 선언할 때 바로 `<[T] extends [string]>`하는 것이 불가능하므로 한 번 더 컨디셔널 타입으로 묶어 선언함
```ts
// 에러 발생
function test<T>(a:T){
  type R<T> = T extends string ? T : T
  const b: R<T> = a // Type 'T' is not assignable to type 'R<T>'
}

// 해결 코드
function test<T extends ([T] extends [string] ? string : never)>(a:T){
  type R<T> = [T] extends [string] ? T: T
  const b: R<T> = a
}
```

## 2.16 함수와 메서드를 타이핑하자
---
### 함수의 매개변수 타이핑
#### 기본적인 매개변수
- ?이 붙거나, 기본값이 제공되면 옵셔널이다.
```ts
function example(a:string, b?:number, c=false){}
example('hi',123,true);
example('hi',123);
example('hi');
```
#### 나머지 매개변수
- 나머지 매개변수 문법을 사용하는 매개변수는 **항상 배열이나 튜플 타입**이어야 한다.
- 나머지 매개변수는 **매개변수의 마지막 자리**에만 위치해야 한다.
```ts
function example1(a:string, ...b:number[]){}
example1('hi',123,4,56);
function example2(...a:string, ...b:number[]){} // 에러 발생!

function example3(...args:[number,string,boolean]){}
example3(1,'2',false);
function example4(...args:[a:number,b:string,c:boolean]){}
```
#### 구조분해 할당
- 타이핑 주의, `{구조분해할당} : {구조분해할당:타입}`
```ts
function destructuring({prop:{nested}}:{prop:{nested:string}}){}
destructuring({prop:{nested:'hi'}})
```
### 함수 내부에서 this
- 명시적으로 표기.
- 매개변수의 첫 번째 자리에 표기, 다른 매개변수들은 한 자리씩 뒤로 밀려남.
	- 타입스크립트에서 매개변수 자리에 존재하는 this는 실제 매개변수가 아니다. 
- this에 타입을 표기했다고 해서 this를 쓸 수 있는 것은 아니다. 
	- call 메서드 등을 활용해 this의 값을 명시적으로 지정해줘야 한다. 
```ts
function example1(){
	console.log(this)
}

function example2(this:Window){
	console.log(this)
}

function example3(this:Document,a:string,b:"this"){}

example3(document,'hello','this') // 에러 발생! Expected 2 arguments, but got 3.
example3.call(document,'hello','this') // call 메서드 등을 활용해 this의 값을 명시적으로 지정함
```
### 메서드에서 this
* 일반적으로는 this가 메서드를 갖고 있는 객체 자신으로 추론되므로 this를 명시적으로 타이핑할 필요가 없다.
* 하지만 this가 바뀔 수 있을 때는 명시적으로 타이핑해야한다.
```ts
type Animal = {
	age:number;
	type:'dog'
}
const person = {
	name:'zero',
	age:28,
	sayName(){
		this;
		this.name;
	},
	sayAge(this:Animal){
		this;
		this.type;
	},
}
person.sayAge.bind({age:3,type:'dog'})
```
### 생성자의 타입
자바스크립트에서는 함수를 생성자로 사용할 수 있다. new 를 붙여서 객체를 만들 수 있다.
* `하지만 타입스크립트에서는 기본적으로 함수를 생성자로 사용할 수 없다.`
* **`대신 class를 써야 한다.`**

## 2.17 같은 이름의 함수를 여러 번 선언할 수 있다 (오버로딩)
---
### 오버로딩
**호출할 수 있는 함수의 타입을 미리 여러 개 타이핑**해두는 기법입니다.

```ts

function add(x: number, y: number): number

function add(x: string, y: string): string

function add(x: any, y: any) {

return x + y

}

  

add(1, 2) // 3

add("1", "2") // '12'

add(1, "2") // ERROR

add("1", 2) // ERROR

```

1. **함수 선언문**만 가능합니다.
2. 오버로딩을 선언하는 순서도 타입 추론에 영향을 끼칩니다.
    - 위에서 아래로 타입을 매칭하기 때문에, 오버로딩의 순서는 **좁은 타입부터 넓은 타입순**으로 오게 해야 문제가 없습니다.

3. 인터페이스로도 오버로딩을 표현할 수 있습니다.

```ts

interface Add {
 (x: number, y: number): number
 (x: string, y: string): string
}

const add: Add = (x: any, y: any) => x + y

add(1, 2) // 3
add("1", "2") // '12'
add(1, "2") // ERROR
add("1", 2) // ERROR
```

4. 타입 별칭으로도 오버로딩을 표현할 수 있습니다.

```ts

type Add1 = (x: number, y: number) => number
type Add2 = (x: string, y: string) => string
type Add = Add1 & Add2
const add: Add = (x: any, y: any) => x + y

add(1, 2) // 3
add("1", "2") // '12'
add(1, "2") // ERROR
add("1", 2) // ERROR
```

5. 유니언이나 옵셔널 매개변수를 활용할 수 있는 경우는 오버로딩을 쓰지 않는 게 좋습니다.

```ts

//bad!

function a(param: string): void
function a(param: number): void
function a(param: string | number) {}
function errorA(param: string | number) {
  a(param)
}

function b(p1: string): void
function b(p1: string, p2: number): void
function b(p1: string, p2?: number) {}
function errorB(p1: string, p2?: number | undefined) {
  b(p1, p2)
}

```


```ts

// good!
function a(param: string | number) {}
function errorA(param: string | number) {
  a(param)
}

function b(p1: string, p2?: number) {}
function errorB(p1: string, p2?: number | undefined) {
  b(p1, p2)
}

```


## 2.18 콜백 함수의 매개변수는 생략 가능하다
---

```ts

function example(callback: (error: Error, result: string) => void) {}
example((e, r) => {})
example(() => {})
example(() => true)

```


```ts

// 이렇게도 바꿀 수 있다!

interface CallBack {
  (error: Error, result: string): void
}

function example(callback: CallBack) {}
// ... 동일함

```

### 함수가 콜백 함수로 사용될 때 발생하는 타입스크립트의 특징.

1. 인수로 제공하는 **콜백 함수의 매개변수에는 타입을 표기하지 않아도 됩니다**.
2. 함수를 선언할 때 콜백 함수에 대한 타입을 표기했으므로 이 타입으로 콜백 함수의 매개변수의 타입을 추론합니다.
	- 이런 현상을 **문맥적 추론**이라고 합니다.
3. **콜백 함수의 매개변수는 함수를 호출할 때 사용하지 않아도 됩니다**.
	- 콜백 함수에 error 매개변수와 result 매개변수 자리가 없어도 호출할 수 있습니다.
	- 여기서 많이 하는 실수가 괜히 error?과 result?처럼 옵셔널로 만들어버리는 것입니다.
	- 콜백 함수의 매개변수 error와 result는 각각 Error, string 타입입니다. (둘 다 undefined가 아닙니다!)
	- 옵셔널로 만들면 error와 result의 타입이 각각 Error | undefined, string | undefined가 되므로 처음의 의도와 달라지는 문제가 발생합니다.
4. **콜백 함수의 반환값이 void일 때는 어떠한 반환값이 와도 상관없습니다**. 다만 해당 반환값은 다른 곳에 사용되지 않습니다. 배열의 forEach 메서드를 생각해보면 쉽게 알 수 있습니다.

	- forEach 메서드의 콜백 함수는 callbackfn 타입입니다.
```tsx

;[1, 2, 3].forEach((item, index, array) => {
  console.log(item, index, array)
})
;[1, 2, 3].forEach((item, index) => {})
;[1, 2, 3].forEach((item) => item)

```


## 2.19 공변성과 반공변성을 알아야 함수끼리 대입할 수 있다
---
### 공변성
- A -> B 일 때 `T<A> -> T<B>` 인 경우
- 쉽게 얘기하자면, 좁은 타입을 넓은 타입에 대입할 수 있다.

### 반공변성
- A -> B 일 때 `T<B> -> T<A>`인 경우
- 쉽게 얘기하자면, 넓은 타입을 좁은 타입에 대입할 수 있다.


### 이변성
- A -> B 일 때 `T<A> -> T<B>`도 되고 `T<B> -> T<A>`도 되는 경우
- 쉽게 얘기하자면, 좁은 타입을 넓은 타입에 대입할 수 있고, 넓은 타입을 좁은 타입에 대입할 수 있다.

### 무공변성
- 아무것도 안되는 경우.

  

### 함수의 매개변수와 반환값의 특징
타입스크립트는 "strict" 옵션을 사용해야한다. (사용하지 않으면 타입스크립트 쓰는 의미가 없다.)
1. **기본적으로 타입스크립트는 공변성**을 갖고 있다.
2. 함수의 **매개변수는 반공변성**을 갖는다.
	- **strict 옵션이 적용되지 않았으면 매개변수는 이변성**을 갖는다.
3. 함수의 **반환값은 공변성**을 갖는다.
	- **strict 옵션이 적용되지 않았어도 공변성**을 갖는다.
### 함수의 반환값: 공변성
```ts

type One = (a: string) => string | number
declare const func1: (a: string) => string | number
declare const func2: (a: string) => string
declare const func3: (a: string) => string | number | boolean

const one: One = func1
const two: One = func2
const three: One = func3 // Error

```

### 함수의 매개변수: 반공변성

```ts

type One = (a: string | number) => void
declare const func1: (a: string) => void
declare const func2: (a: string | number) => void
declare const func3: (a: string | number | boolean) => void

const one: One = func1 // Error
const two: One = func2
const three: One = func3
```

  

### 객체의 메서드: 타이핑 방법에 따라 변성이 정해짐

```ts

// strict 옵션 활성화된 상태

interface SayMethod {
  say(a: string | number): string
}

interface SayFunction {
  say: (a: string | number) => string
}

interface SayCall {
  say: {
    (a: string | number): string
  }
}

const sayFunc = (a: string) => "hello"
const MyAddingMethod: SayMethod = { say: sayFunc } // 이변성 -> 왜 될까??
const MyAddingFunction: SayFunction = { say: sayFunc } // 반공변성 -> Error
const MyAddingCall: SayCall = { say: sayFunc } // 반공변성 -> Error

```

  
`const MyAddingMethod: SayMethod = { say: sayFunc } // 이변성` 이 가능한 이유
- **'함수(매개변수): 반환값'** 으로 선언한 것은 **매개변수가 이변성**을 가지기 때문입니다.
- **'함수(매개변수)=> 반환값'** 으로 선언한 것은 **매개변수가 반공변성**을 가집니다.


## 2.20 클래스는 값이면서 타입이다
---
- 자바스크립트와 주요한 차이점은, 타입스크립트는 생성자를 통해 멤버 변수를 설정할 때 필드에 미리 멤버를 선언해둬야 한다는 점입니다. 멤버의 타입은 생략할 수 있습니다. 
- 타입스크립트가 생성자 함수를 통해 알아서 추론합니다.
- **멤버는 항상 constructor 내부와 짝이 맞아야 합니다.**
```tsx
class Person {
  name;
  age;
  married;
  constructor(name:string,age:number,married:boolean){
    this.name = name
    this.age = age
    this.married = married
  }
}
```

* 조금 더 **엄격하게 타입 검사를 하고 싶다면 `implements` 예약어**를 사용하면 됩니다.
```tsx
interface Human {
  name:string;
  age:number;
  married:boolean;
  sayName():void;
}

class Person implements Human {
  name;
  age;
  married;
  sayName;
  constructor(name:string,age:number,married:boolean,sayName:()=>void){
    this.name = name
    this.age = age
    this.married = married
    this.sayName = sayName
  }
}
```

* 타입스크립트는 **생성자 함수 방식으로 객체를 만드는 것을 지원하지 않습니다.**
	* 따라서 클래스가 new를 붙여 호출할 수 있는 유일한 객체입니다.
```tsx
function Person(){
}
new Person() // Error
```

- 클래스는 타입스크립트에서 **값으로 쓰이면서 타입**이 되기도 합니다.
```tsx
const person1: Person = new Person('zero',28,false)
const P: typeof Person = Person
const person2 = new P('nero',28,false)
```

- 클래스 멤버로는 옵셔널, readonly, public, protected, private 수식어가 추가될 수 있습니다.
	- 옵셔널(`?`) : 있어도 되고 없어도 됨
		- 옵셔널 파라미터는 매개변수의 가장 마지막에 위치해야함. 
	- readonly: 읽기만 가능, 변경 불가능
	- public: protected나 private이 아니면 기본적으로 public이다. 선언한 자신의 클래스, 자손 클래스, new 호출로 만들어낸 인스턴스에서 속성을 사용할 수 있다. 자손 클래스란 extends로 상속받은 클래스를 의미한다. 
		- implements하는 인터페이스의 속성은 전부 public 이어야 합니다.
	- protected: 선언한 자신의 클래스, 자손 클래스에서 속성을 사용할 수 있다.
	- private: 선언한 자신의 클래스에서만 속성을 사용할 수 있다.
		- private 키워드 보단 자바스크립트에서 자체적으로 지원해주는 `#`을 속성 앞에 붙여서 사용하자. 

| 수식어       | 자신 클래스 | 자손 클래스 | 인스턴스 |
| --------- | ------ | ------ | ---- |
| public    | O      | O      | O    |
| protected | O      | O      | X    |
| private   | O      | X      | X    |
- 클래스 메서드에는 `override` 수식어가 있는데, 이 수식어를 활용하려면 tsconfig메뉴에서 noImplicitOverride 옵션이 체크되어 있어야 합니다.
	- override할 경우엔 반드시 override 수식어를 붙여야 합니다.
```tsx
class Human {
  eat(){
    console.log('냠냠');
  }
  sleap(){
    console.log('쿨쿨');
  }
}

class Employee extends Human{
  work(){
    console.log('끙차')
  }
  override sleap(){
    console.log('에고고')
  }
}
```

- 클래스의 **생성자 함수**에도 **오버로딩**을 적용할 수 있습니다.
- 클래스의 **속성**에도 **인덱스 시그니처**를 사용할 수 있습니다.
- 클래스의 **static 속성**에도 **인덱스 시그니처**가 가능합니다.
```tsx
class Signature {
  [propName:string]: string | number | undefined;
  static [propName:string]: boolean
}
const sig = new Signature()
sig.hello = 'world';
Signature.isGood = true
```

- 클래스나 인터페이스의 **메서드**에서는 **this를 타입**으로 사용할 수 있습니다.
```tsx
class Person{
 age:number;
 married:boolean;
 constructor(age:number,married:boolean){
  this.age = age;
  this.married = married;
 }
 sayAge(){
  console.log(this.age)
 }
 sayMarried(this:Person){
  console.log(this.married)
 }
 sayCallback(callback:(this:this)=>void){
  callback.call(this)
 }
}

const p = new Person('zero',2,false)
p.sayCallback(function(this:Person){
  console.log('hi '+ this.name) // hi zero
})
```

- 인터페이스로 클래스 생성자를 타이핑할 수 있습니다. 메서드를 선언하는 것과 비슷한데, 앞에 new 연산자를 추가하면 됩니다.
```tsx
interface PersonConstructor{
 new (name:string,age:number):{
  name:string;
  age:number;
 }
}

class Person{
 name:string;
 age:number;
 constructor(name:string,age:number){
  this.name = name;
  this.age = age;
 }
}

function createPerson(ctor:PersonConstructor, name:string,age:number){
 return new ctor(name,age)
}
createPerson(Person,'zero',28)
```

### 2.20.1 추상 클래스
- `abstract class`: implements 보다 조금 더 구체적으로 클래스의 모양을 정의하는 방법입니다. 
- abstract class의 **속성과 메서드는 abstract**일 수 있습니다. abstract 인 경우 **실제 값은 없고 타입 선언**만 되어 있습니다. 
- abstract class를 상속하는 클래스에서 반드시 abstract 속성이나 메서드를 구현해야 합니다.
- implements와 다르게 abstract 클래스는 실제 자바스크립트 코드로 변환됩니다.
- 객체의 타이핑을 위해 인터페이스를 사용하느냐, 클래스를 사용하느냐는 취향 차이라고 할 수 있습니다. 또는 자바스크립트로 변환한 후에도 코드로 남아야 하는 경우에는 클래스를 사용하고 그게 아니라면 인터페이스를 사용하면 됩니다. 
```tsx
abstract class AbstractPerson {
 name:string;
 age:number
 abstract value: number;
 constructor(name:string,age:number){
  this.name=name
  this.age=age
 }
 sayName(){
  console.log(this.name)
 }
 abstract sayAge():void
}

class Person extends AbstractPerson {
 value:number = 0;
 sayAge(){
  console.log(this.age)
 }
}
// 혹은
class Person extends AbstractPerson {
 value:number;
 constructor(name:string,age:number,value){
  super(name,age)
  this.value = value
 }
 sayAge(){
  console.log(this.age)
 }
}
```
## 2.21 enum은 자바스크립트에서도 사용할 수 있다
---
**enum: 열거형** 이라는 타입입니다.
- 실제 자바스크립트 코드로 사용할 수 있습니다.
```tsx
enum Level {
 NOVICE,
 INTERMEDIATE,
 ADVANCED,
 MASTER
}
// 이 코드는 다음과 같이 변합니다.
var Level = {
 0:'NOVICE',
 1:'INTERMEDIATE',
 2:'ADVANCED',
 3:'MASTER'
 NOVICE:0,
 INTERMEDIATE:1,
 ADVANCED:2,
 MASTER:3
}
```

- **멤버의 순서대로 0부터 숫자를 할당**합니다. **0대신 다른 숫자를 할당**하면 그 **다음 멤버는 다른 숫자 +1**이 됩니다. 
	- ex) NOVICE = 3 -> INTERMEDIATE = 4, ADVANCED = 7 -> MASTER = 8
- **문자열도 할당 가능**합니다. 다만 **한 멤버를 문자열로 할당하면 그 다음부터는 전부 직접 값을 할당**해야 합니다.
- enum 타입의 속성은 값으로도 활용할 수 있습니다.
```tsx
enum Level {
 NOVICE,
 INTERMEDIATE,
 ADVANCED,
 MASTER
}
const a = Level.NOVICE // 0
const b = Level[Level.NOVICE] // NOVICE
```
- **`enum변수[enum변수.멤버이름] 은 "멤버 이름"`**
  `ex) console.log(Level[Level.NOVICE) // "NOVICE"`
- enum은 값으로 사용하기보다는 타입으로 사용하는 경우가 더 많습니다. 
	- **enum을 타입**으로 사용하면 **멤버의 유니온과 비슷한 역할**을 합니다. 
```tsx
// 위에서 이어짐
function whatsYourLevel(level:Level){
 console.log(Level[level])
}
const myLevel = Level.ADVANCED;
whatsYourLevel(myLevel)

// 만약 숫자 enum과 문자열 enum 혼용한다면?
enum Level {
 NOVICE,
 INTERMEDIATE,
 ADVANCED,
 MASTER = 'masterDegree'
}
// 타입 가드(타입 좁히기) 필요함
function whatsYourLevel(level:Level){
 if(typeof level === 'number'){
  console.log(Level[level])
 }else{
  console.log(Level.MASTER)
 }
}

const myLevel = Level.ADVANCED;
const myLevel2 = Level.MASTER;
whatsYourLevel(myLevel)
whatsYourLevel(myLevel2)
```

- enum 타입은 **브랜딩**을 위해 사용하면 좋습니다.
	- 다만 브랜드 속성으로 같은 enum의 멤버를 사용해야 서로 구분이 가능합니다.
	- 다른 enum의 멤버끼리는 구분되지 않을 수 있습니다.
- enum 타입을 사용하되 자바스크립트 코드가 생성되지 않게 할 수 있습니다.
	- **const enum**
```tsx
const enum Money {
 WON,
 DOLLAR,
}
Money.WON // 0
Money[Money.WON] // Error -> 객체가 없으므로 에러 발생
```


## 2.22 infer로 타입스크립트의 추론을 직접 활용하자
---
- **infer 예약어**
- 컨디셔널 타입과 함께 사용
- 다음과 같은 상황에서 쓸 수 있습니다. 배열이 있을 때 배열의 요소 타입을 얻어내는 상황.
```tsx
type El<T> = T extends (infer E)[] ? E : never
type Str = El<string[]> // type Str = string
type NumOrBool = El<(string | boolean)[]> // type NumOrBool = number | boolean
```
- 컨디셔널 타입에서 타입 변수는 참 부분에서만 쓸 수 있습니다. 거짓 부분에서 쓰려고 하면 에러가 발생합니다.
  `ex) type El<T> = T extends (infer E)[] ? never : E // Error`

- 추론하려는 부분을 infer로 만들면 됩니다. 다음은 매개변수, 생성자 매개변수, 반환값, 인스턴스 타입을 추론하는 타입입니다.
	- (...args: any) => any 는 임의의 함수를 타이핑하는 부분이고, abstract new (...args: any)=> any 는 임의의 생성자를 타이핑하는 방법입니다. 이 둘에서 추론하길 원하는 매개변수와 반환값 부분을 infer로 바꾸면 됩니다.
```tsx
type MyParameters<T> = T extends (...args: infer P)=>any ? P : never
type MyConstructorParameters<T> = T extends abstract new (...args: infer P)=>any ? P : never
type MyReturnType<T> = T extends (...args:any)=>infer R ? R : any
type MyInstanceType<T> = T extends abstract new (...args: any)=> infer R ? R : any

type P = MyParameters<(a:string, b:number) => string> // type P = [a:string, b:number]
type R = MyReturnType<(a:string, b:number) => string> // type R = string
type CP = MyConstructorParameters<new (a:string, b:number) => {}> // type CP = [a:string, b:number]
type I = MyInstanceType<new (a:string, b:number) => {}> // type I = {}
```

서로 다른 타입 변수를 여러 개 동시에 사용할 수도 있습니다.
- 매개변수는 P , 반환값은 R 타입 변수로 추론한 모습입니다.
```tsx
type MyPAndR<T> = T extends (...args: infer P) => infer R ? [P,R] : never

type PR = MyPAndR<(a:string,b:number)=>string> // type PR = [[a:string,b:number],string]
```

반대로 같은 타입 변수를 여러 곳에 사용할 수도 있습니다.
```tsx
type Union<T> = T extends {a:infer U,b:infer U}? U : never 
type Result1 = Union<{a:1|2 , b:2|3}> // type Result1 = 1 | 2 | 3

type Intersection<T> = T extends {a:(pa:infer U)=>void, b:(pb:infer U)=>void} ? U : never
type Result2 = Intersection<{a(pa:1|2):void,b(pb:2|3):void}> // type Result2 = 2
```
- union
	- **같은 이름의 타입 변수**는 서로 유니언이 됩니다.
	- **반환값** 타입을 같은 타입 변수로 선언한 경우에는 반환값이 공변성을 갖고 있기에 유니언이 됩니다.
- intersection
	- **매개변수는** 반공변성을 갖고 있으므로 인터섹션이 됩니다.
- 같은 타입 변수 중에서 하나가 매개변수고, 하나가 반환값이면 반환값이 매개변수의 부분집합인 경우에만 그 둘의 교집합이 됩니다. 그 외의 모든 경우는 never가 됩니다.
```tsx
type ReturnAndParam<T> = T extends{
 a:()=>infer U,
 b:(pb:infer U)=>void
} ? U : never
type Result3 = ReturnAndParam<{a:()=>1|2, b(pb:1|2|3):void}> // type Result3 = 1|2
type Result4 = ReturnAndParam<{a:()=>1|2, b(pb:2|3):void}> // type Result4 = never
```

매개변수에 같은 타입 변수를 선언하면 인터섹션이 된다는 사실을 바탕으로 유니언을 인터섹션으로 만드는 타입을 작성할 수 있습니다. 
```tsx
type UnionToIntersection<U> = 
(U extends any ? (p:U)=>void : never) extends (p:infer I)=>void ? I : never

type Result5 = UnionToIntersection<{a:number} | {b:string}> // type Result5 = {a:number} & {b:string}
type Result6 = UnionToIntersection<boolean | true> // type Result6 = never

```
- U는 제네릭이자 유니언이므로 컨디셔널 타입에서 분배법칙이 실행됩니다. 
- 타입 변수 I는 추론에 따라 {a:number}와 {b:string}이 됩니다. 타입 변수 I는 매개변수이므로 인터섹션이 실행되어 최종적으로 `{a:number} & {b:string}`이 됩니다.
- boolean은 true | false 이므로 `UnionToIntersection<true | false | true>` 가 되므로 true & false & true는 never가 됩니다.
## 참고자료
[구조적 타이핑, 유니언, 인터섹션 설명](https://yongdam.sh/blog/effective-typescript-structural-typing)
[keyof typeof 사용법](https://inpa.tistory.com/entry/TS-%F0%9F%93%98-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-keyof-typeof-%EC%82%AC%EC%9A%A9%EB%B2%95)








