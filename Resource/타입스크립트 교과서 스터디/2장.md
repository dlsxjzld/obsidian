```table-of-contents
title: 
style: nestedList # TOC style (nestedList|nestedOrderedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```
---
배운 것을 모두 외울 필요는 없다. 한두 번 훑어본 뒤 바로 실전 라이브러리 분석으로 넘어가라. 분석하면서 배웠던 것이 기억나지 않는다면 다시 돌아와서 복습하면 된다.

학습 → 실전 라이브러리 분석 → 다시 학습 (애자일 학습 방법?!)
### 2.1 변수, 매개변수, 반환값에 타입을 붙이면 된다
---
- 변수
	const str: string = ‘hello’;

- 매개변수, 반환값
	const minus = (x:number, y:number): number ⇒ x-y;
### 2.2 타입 추론을 적극 활용하자
---
- **`타입스크립트가 타입을 제대로 추론하면 그대로 쓰고, 틀리게 추론할 때만 올바른 타입을 표기한다.`**
- 명시적으로 타입을 부여하지 않아도 타입스크립트는 타입을 알고 있는 경우가 있다.
- 반환값을 어떤 변수에 대입했기 때문에 반환값의 타입은 추론 가능하다.
```ts

const plus = (x, y): number => x + y

const result1 = plus(1, 2) // result1 은 number로 타입 추론됨

  

const plus = (x: number, y: number) => x + y

const result1 = plus(1, 2) // result1 은 number로 타입 추론됨

  

// 문제는 매개변수 x,y에 타입을 지정하지 않아서 암묵적으로 any 타입을 갖고 있다고 추론한다.

// 문제를 해결하면

const plus = (x: number, y: number): number => x + y

```
  

- 리터럴 타입, 넓은 타입
```ts

// const: 리터럴 타입 -> 타입 추론이 더 정확함

const str = "hello" // const str: 'hello'

const num = 123 // const num: 123

const n = null // const n: null

const u = undefined // const n: undefined

const sym = Symbol("sym") // const sym: typeof sym // unique symbol

const obj = { hello: "world" } // const obj: {hello: string}

  

// let: 더 넓은 타입

let str = "hello" // let str: string

let num = 123 // let num: number

let n = null // let n: any

let u = undefined // let n: any

let sym = Symbol("sym") // let sym: Symbol

let obj = { hello: "world" } // let obj: {hello: string}

  

// null과 undefined를 let 변수에 대입할 때는 any로 추론한다.

// unique symbol 끼리는 서로 비교할 수 없다.

```
### 2.3 값 자체가 타입인 리터럴 타입이 있다
---
- 타입 스크립트에서는 표기한 타입과 일치하는 값만 대입할 수 있다. (=== 자바스크립트의 자유도를 희생하는 대신 타입 안정성을 챙기는 언어)

	`let: 더 넓은 타입`, 같은 string이면 넣을 수 있다
	`const: 리터럴 타입`, 표기한 타입과 일치하는 값만 넣을 수 있다

- 함수 리터럴 타입에서는 반환값의 표기법이 다르다. (콜론 대신 ⇒를 사용)
```ts

const plus = (x: number, y: number): number => x + y

const plus: (x: number, y: number) => number = (x, y) => x + y

```

### 2.4 배열 말고 튜플도 있다
---
- 배열의 타입은 **`타입[]`** 또는 **`Array<타입>`**
- **튜플: 각 요소 자리에 타입이 고정되어 있는 배열**
- 튜플은 push, pop, unshift, shift를 막지 않는다.
	push를 사용할 수 있지만 tuple[4]처럼 인덱스에 접근할 수가 없으니 딱히 의미가 없다.
	**push를 사용하는 것까지 막으려면 `readonly`수식어를 붙여줘야 한다**.
	그러면 튜플을 수정할 수 없다.
```ts

const array = [1,2,3]

array[3].toFixed();

// -> array[3] 이 undefined인데도 toFixed를 붙일 수 있는 문제가 있음

  

// 튜플을 통해 해결 가능!

const array: [number, number, number] = [1,2,3]

array[3].toFixed() // -> Object is possibly 'undefined'

  

const tuple: [number,boolean,string] = [1,false,'hi']

tuple.push('hi') // 가능

tuple[4] = 'what' // 에러 발생

  

const tuple: readonly [number,boolean, string] = [1,fals,'hi']

tuple.push('hi') // 수정 할 수 없도록 변경!

```

- **튜플은 길이가 고정된 배열 X, 각 요소 자리에 타입이 고정되어 있는 배열 O**
- …타입[] 표기를 통해 특정 타입이 연달아 나올 수 있다.
```ts

const strNumBools: [string, number, ...boolean[]]

= ['hi', 123, false, true, false]

```

- 타입이 아니라 값에 전개 문법을 사용해도 타입스크립트는 타입 추론을 해낸다.
* 구조분해 할당에서는 나머지 속성 문법을 사용할 수 있으며 이 경우에도 타입을 알아서 추론한다.
```ts

// 값에 전개 문법을 사용

const arr1 = ["hi", true]

const arr = [46, ...arr1]

// const arr: (string | number | boolean)[]

  

// 구조분해 할당 나머지 속성 문법

const [a, ...rest1] = ["hi", 1, 2, 3]

// const a:string, const rest1: [number,number,number]

```

- **타입 뒤에 `?`** 가 붙으면 `옵셔널 수식어`로 `해당 자리에 값이 있어도 그만, 없어도 그만`

- [number, boolean?, string?]

- [number]

- [number, boolean]

- [number, boolean, string]

  

### 2.5 타입으로 쓸 수 있는 것을 구분하자
---
- 값은 일반적으로 자바스크립트에서 사용하는 값
- 타입은 타입을 위한 구문에서 사용하는 타입
- **`타입을 값으로 사용할 수 없다.`**
- **타입으로 사용할 수 있는 값과 타입으로 사용할 수 없는 값만 구분하면 된다.**
- 대부분의 **리터럴 값**은 **타입으로 사용 할 수 있음**
- **변수의 이름**은 **타입으로 사용 할 수 없음.**
- **변수에는 typeof를 앞에 붙여 타입으로 사용할 수 있다.**
- 함수는 자바스크립트에서 일급 객체다. 일급 객체는 값이므로 변수에 할당할 수 있다.
- 함수를 담은 변수의 이름 앞에 typeof를 붙여 타입으로 사용할 수 있다.
- 함수의 호출은 타입으로 사용할 수 없다.
- 함수의 반환값을 타입으로 사용하고 싶다면 3.3절의 ReturnType을 참조
- **클래스의 이름은 typeof 없이도 타입으로 사용할 수 있다.**

### 2.6 유니언 타입으로 OR 관계를 표현하자
---
유니언 타입 : 하나의 변수가 여러 타입을 가질 수 있다는 가능성을 표시
유니언 타입 표기 연산자 : `|`
```ts
let strOrNum = string | number = 'hello'
strOrNum = 123
```

* 유니언 타입으로부터 정확한 타입을 찾아내는 기법을 타입 좁히기라고 부름
* 운좋게 각 유니언 타입에 모두 공통적인 속성이 들어 있는 경우에는 타입 좁히기를 할 필요가 없음.
```ts
// 타입 좁히기
function returnNumber(value:string | number):number {
  if(typeof value === 'number'){
    return value // number
  }
  // typeof value === string
  return parseInt(value)
}

// 공통적인 속성 === 타입 좁히기 할 필요 X
function returnString(value:string | number | boolean):string {
  return value.toString()
}
returnString(1)
returnString('1')
returnString(true)
```

### 2.7 타입스크립트에만 있는 타입을 배우자
---
#### any
**any 타입은 타입 검사를 포기한다는 선언과 같다. 타입스크립트가 any로 추론하는 타입이 있다면 타입을 직접 표기해야 한다.**

대부분의 경우 타입이 any로 추론되면 다음과 같이 implicitAny 에러가 발생한다.

하지만 다음과 같이 any로 추론 되어도 에러가 발생하지 않는 경우들이 있다.
* 빈 배열
명시적으로 any를 반환하는 경우
* JSON.parse
* fetch
이럴 때는 any가 아닌 타입을 표기하면 된다.
* <{data:string}> 은 제네릭이라는 문법으로 2.14절에서 배운다.
* then 메서드에 타이핑한 것이 어떻게 다음 then 메서드에 영향을 미치는지는 3.10절에서 알아보자.
```ts
const arr = [] // const arr: any[]
const arr: string[] = [] // const arr: string[]

fetch('url').then<{data: string}>((respoonse)=>{
  return response.json()
}).then((result)=>{
  // (parameter) result: {data:string}
})
const result: {hello:string} = JSON.parse('{"hello":"json"}'})
```
#### unknown
unknown 은 모든 타입을 대입할 수 있지만, 그 후 어떠한 동작도 수행할 수 없게 된다. 
대부분 try catch 문에서 unknown을 보게 된다.
* e가 unknown이므로 그 뒤에 어떠한 동작도 수행할 수 없게 된다. 
* catch문의 e에는 any와 unknown 외의 타입을 직접 표기할 수 없다. 
	* 이럴 때는 ==as로 타입을 주장==할 수 있다. 
	* as : 타입 주장
	* !(non-null assertion) : null이 아님을 주장
	* as와 !는 모두 강제로 주장한 것이므로 자신이 책임져야 합니다.
```ts
try{}
catch(e){ // var e: unknown
  const error = e as Error
  // const error = <Error>e
  console.log(error.message)
}
```
#### void
 함수의 반환값이 없는 경우 반환값이 void 타입으로 추론된다.
* void는 함수의 반환값을 무시하도록 하는 특수한 타입이다. 
* 반환값을 실제로 받을 수는 있지만 **타입이 void가 되면서 다른 동작을 더 진행할 수 없게** 된다. 
```ts
const func: ()=>void = ()=>3
const value = func()
console.log("value:",value+4) // Operator '+' cannot be applied to types 'void' and 'number'.(2365)

const func2 = ():void=>3 // Type 'number' is not assignable to type 'void'.
const value2 = func2()
console.log("value2:",value2+4);

const func3: ()=>void | undefined = ()=>3 // Type 'number' is not assignable to type 'void'.
```

* void를 활용하여 반환값을 무시하는 특성은 콜백 함수에 주로 사용한다. 
* 사용자가 그때그때 반환값을 다르게 정할 수 있으므로, 어떠한 반환값이든 다 받을 수 있는 void타입이 등장하게 되었다.
```ts
const callbackfn: (v:number)=>void = (v)=>console.log(v);

[1,2,3].forEach(callbackfn)
[1,2,3].forEach((v:number)=>console.log(v))
```

정리하면 void는 2가지 목적을 위해 사용한다.
1. 사용자가 함수의 반환값을 사용하지 못하도록 제한한다.
2. 반환값을 사용하지 않는 콜백 함수를 타이핑할 때 사용한다.
#### {},Object
객체의 타입이 아니라 null, undefined를 제외한 모든 타입을 의미.
* {}타입에 null과 undefined를 합치면 unknown과 비슷해진다.
```ts
const unk: unknown = 'hello'
if(unk){
  unk // const unk: {}
}else{
  unk // const unk: unknown
}
```
#### never
never 타입에는 어떠한 타입도 대입할 수 없다. 
* 함수 표현식 : never 타입 반환
* 함수 선언문 : void 타입 반환
	* 함수 선언문은 명시적으로 never타입을 직접 표기해야한다. 
never 타입이 나오는 상황
* while(true) 같이 무한 반복되는 경우 
* throw new Error()

### 2.8 타입 별칭으로 타입에 이름을 붙이자
---
특정 타입을 특정 이름에 저장할 수 있다.
```ts
type A = string
const str: A = 'hello'
```
기존 타입에 새로 이름을 붙인 것을 **==타입 별칭==** 이라고 부른다.
* type 키워드를 사용해서 선언할 수 있다.
* 대문자로 시작하는 단어로 만드는 것이 관습이다.
* 주로 복잡하거나 가독성이 낮은 타입에 붙인다.
* 함수 외에는 객체나 배열을 주로 타입 별칭으로 분리한다.
```ts
const func1: (value:number,unit:string)=>string = (value,unit)=>value+unit

type ValueWithUnit = (value:number, unit:string)=>string
const func2: ValueWithUnit = (value,unit)=>value+unit
```

```ts
type Person = {
  name:string,
  age:number,
  married:boolean
}
const person2:Person = {
  name:'zero',
  age:28,
  married:false
}
```

### 2.9 인터페이스로 객체를 타이핑하자
---
==인터페이스 선언==을 사용하면 객체 타입에 이름을 붙일 수 있다. 
* 객체를 타이핑 하는 방법은 type ([[2장#2.8 타입 별칭으로 타입에 이름을 붙이자]]) 도 있다.
* 타입 별칭과 마찬가지로 ==대문자로 시작하는 단어==로 만드는 것이 관습이다.
* ` ; ,` 로 구분 가능하지만 하나로 통일해서 쓰자.
* 인터페이스의 속성 키 자리에 [key: number] 라는 문법이 있는데 이는 이 객체의 length를 제외한 속성 키가 전부 number라는 의미이다. 이 문법을 ==인덱스 시그니처== 라고 부른다. length는 인덱스 시그니처 이전에 표기했으므로 number가 아니어도 된다.
```ts
interface Person {
  name:string;
  age:number,
  married:boolean
}
const person2:Person = {
  name:'zero',
  age:28,
  married:false
}
```

```ts
interface Func {
  (x:number, y:number): number
}
const add:Func = (x,y)=>x+y

interface Arr {
  length:number,
  [key:number]:string
}
const arr:Arr = ['3','5','7']
console.log(arr) //['3','5','7']
console.log(arr[0]) // '3'
console.log(arr[1]) // '5'
console.log(arr[2]) // '7'
console.log(arr[3]) // undefined
console.log(arr.length) // 3
```

#### 2.9.1 인터페이스 선언 병합
---
인터페이스와 인터페이스를 합칠 수 있다.
```ts
interface Merge {
  one:string,
}
interface Merge {
  two:number
}
const example: Merge = {
 one:'1',
 two:2
}
```
* 같은 이름으로 여러 인터페이스를 선언할 수 있다. 이러면 모든 Merge 인터페이스가 하나로 합쳐진다. 이를 ==선언 병합==이라고 부른다. 이러한 기능을 만들어둔 이유는 나중에 다른 사람이 인터페이스를 확장할 수 있도록 하기 위함이다.
* 다만 인터페이스 간에 속성이 겹치는데 타입이 다를 경우에는 에러가 발생한다. 속성이 같은 경우에는 타입도 같아야 한다.
```ts
interface Merge {
  one: string;
}
interface Merge {
  one: number; // 에러 발생! 타입도 같게 해야함
}
```

#### 2.9.2 네임스페이스
--- 
인터페이스 병합에는 큰 단점이 있다. 남이 만든 인터페이스와 의도치 않게 병합될 수 있다는 점이다.
이럴 때를 대비해서 네임스페이스가 있다.
그러나 네임스페이스도 이름이 겹치면 병합될 수 있다. 
이를 방지하기 위해 [[5장 모듈파일]]이 있다.

* ==export== 반드시 필요하다.
* namespace 중첩 된다.
* namespace 내부에 실제 값을 선언한 경우, 네임스페이스 자체를 자바스크립트 값으로 사용할 수 있다.
	* 네임스페이스 내부의 값은 []를 사용해서 접근할 수 있지만, 내부의 타입은 []를 사용해서 접근할 수 없다.
* namespace도 이름이 겹치는 경우 병합된다. 내부에 같은 이름의 인터페이스가 있다면 합쳐지고, 내부에 같은 이름의 타입 별칭이 있다면 에러가 발생한다.
```ts
// export 반드시 필요하다.
namespace Example {
  export interface Inner {
  test:string;
  }
  export type test2 = number;
}
const ex1: Example.Inner = {
  test:'hello',
}
const ex2: Example.test2 = 123
```
```ts
// namespace 중첩
namespace Example {
  export namespace Outer{
    export interface Inner {
      test:string;
    }
    export type test2 = number;
  }
}
const ex1: Example.Outer.Inner = {
  test:'hello',
}
const ex2: Example.Outer.test2 = 123
```
```ts
// 네임스페이스 자체를 자바스크립트 값으로 사용
namespace Ex {
  export const a = 'real'
}
const a = Ex; // {a: 'real'}
const b = Ex.a // 'real'
const c = Ex['a'] // 'real' 
```
